{
  "nodes": [
    {
      "_id": "root",
      "title": "Your App Home",
      "protected": true,
      "cannotDrop": true,
      "acceptDrop": [
        "pages"
      ],
      "isRoot": true,
      "type": "root",
      "to": null,
      "pos": {
        "x": 80,
        "y": 245
      },
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "src": "<template>\n  <div class=\"full\" ref=\"mounter\">\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    nodes: {},\n    \n    components: {},\n    timename: {},\n    timetracks: {}\n  },\n  data () {\n    return {\n      screen: false,\n      syncAll: {},\n      cameras: {},\n      scenes: {},\n      \n      sceneID: '',\n      cameraID: '',\n      \n      mouse: { x: 0, y: 0 },\n      renderer: false\n    }\n  },\n  watch: {\n    cameraID () {\n      window.dispatchEvent(new Event('resize'))\n      this.getSizeInfo()\n      this.syncAll()\n      this.syncScreen()\n    }\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'camera') {\n        this.cameras[child.node._id] = child.camera\n        window.dispatchEvent(new Event('resize'))\n      }\n      if (child.node.type === 'scene') {\n        this.scenes[child.node._id] = child.scene\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestroy () {\n    this.stop()\n    this.$emit('remove', this)\n  },\n  mounted () {\n    // let sceneIDs = this.nodes.filter(t => t.type === 'scene').map(t => t._id)\n    // let cameraIDs = this.nodes.filter(t => t.type === 'camera').map(t => t._id)\n    // this.cameraID = cameraIDs[0]\n    // this.sceneID = sceneIDs[0]\n    this.init()\n  },\n  methods: {\n    init () {\n      this.setupRenderer()\n      this.getSizeInfo()\n      this.setupSizer()\n      this.syncSize()\n      this.start()\n      this.$emit('ready', this)\n    },\n    syncScreen () {\n      let camera = this.cameras[this.cameraID]\n      if (camera) {\n        let depth = 0\n        var aspect = camera.aspect\n        var dist = camera.position.z - (depth) // item\n        var vFOV = THREE.Math.degToRad(camera.fov) // convert vertical fov to radians\n        var screenHeight = 2 * Math.tan(vFOV / 2) * dist // visible height\n        var screenWidth = screenHeight * aspect // visible width\n        this.screen = {\n          aspect,\n          dist,\n          vFOV,\n          screenWidth,\n          screenHeight\n        }\n      }\n    },\n    setupRenderer () {\n      this.renderer = new THREE.WebGLRenderer({\n        antialias: true,\n        alpha: true,\n        preserveDrawingBuffer: true\n      })\n      this.renderer.domElement.style.marginBottom = '-6px'\n      this.$refs['mounter'].appendChild(this.renderer.domElement)\n    },\n    setupSizer () {\n      this.getSizeInfo()\n      window.addEventListener('resize', this.getSizeInfo, false)\n    },\n    getSizeInfo () {\n      if (!this.$refs['mounter']) {\n        return\n      }\n      var rect = this.$refs['mounter'].getBoundingClientRect()\n      this.rect = rect\n      this.size = {\n        width: rect.width,\n        height: rect.height,\n        aspect: rect.width / rect.height\n      }\n      this.dpi = 2.0 // window.devicePixelRatio || 1.0\n    },\n    syncSize () {\n      let sync = () => {\n        let { composer, cameras, renderer, size, dpi, control } = this\n        let camera = cameras[this.cameraID]\n        if (control) {\n          control.update()\n        }\n        if (composer) {\n          composer.setSize(size.width * dpi, size.height * dpi)\n        }\n        \n        renderer.setPixelRatio(dpi)\n        renderer.setSize(size.width, size.height)\n        if (camera) {\n          camera.aspect = size.width / size.height\n          camera.updateProjectionMatrix()\n        }\n        this.syncScreen()\n      }\n      \n      sync()\n      this.syncAll = () => {\n        sync()\n      }\n      window.addEventListener('resize', sync, false)\n\n      this.$refs['mounter'].addEventListener('mousemove', (evt) => {\n        this.mouse.x = evt.pageX\n        this.mouse.y = evt.pageY\n      }, false)\n    },\n    stop () {\n      window.cancelAnimationFrame(this.rAFID)\n    },\n    start () {\n      let rAF = () => {\n        this.rAFID = window.requestAnimationFrame(rAF)\n        this.render()\n      }\n      this.rAFID = window.requestAnimationFrame(rAF)\n    },\n    resolveSwitchableArray () {\n      // console.table(this.timetracks)\n      this.timetracks.filter(track => track.progress > 0.001 && track.progress < 1).forEach((track) => {\n        let item = this.nodes.find(n => n.title === track.title)\n        if (item && item._id) {\n          if (item.type === 'camera') {\n            this.cameraID = item._id\n          } else if (item.type === 'scene') {\n            this.sceneID = item._id\n          }\n        }\n      })\n    },\n    // resolveSwitchable () {\n    // for (var kn in this.timename) {\n    //     if (this.timename[kn] > 0.001 && this.timename[kn] < 1) {\n    //       let item = this.nodes.find(n => n.title === kn)\n    //       if (item && item._id) {\n    //         if (item.type === 'camera') {\n    //           this.cameraID = item._id\n    //           // console.log('use cam ->', item.title)\n    //           // if (this.cameraID !== item._id) {\n    //           //   // window.dispatchEvent(new Event('resize'))\n    //           // }\n    //         } else if (item.type === 'scene') {\n    //           this.sceneID = item._id\n    //           // if (this.sceneID !== item._id) {\n    //           //   // console.log('use scene ->', item.title)\n    //           // }\n    //         }\n    //       }\n    //     }\n    //   }\n    // },\n    render () {\n      let { scenes, cameras, renderer, composer } = this\n      // this.resolveSwitchable()\n      this.resolveSwitchableArray()\n      \n      let scene = scenes[this.sceneID]\n      let camera = cameras[this.cameraID]\n\n      if (scene && camera && renderer && composer) {\n        composer.render()\n      } else if (scene && camera && renderer) {\n        renderer.render(scene, camera)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "sceneID": "homepage",
      "cameraID": "_455500",
      "cannotDelete": false,
      "preventDelete": true,
      "confirmRecylce": false
    },
    {
      "_id": "homepage",
      "title": "Home Scene",
      "protected": true,
      "type": "scene",
      "to": "_29338",
      "pos": {
        "x": 440,
        "y": 300
      },
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "library": [],
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      scene: false\n    }\n  },\n  methods: {\n    init () {\n      this.scene = new THREE.Scene()\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'camera') {\n        this.components[this.node.to].$emit('addChild', { child })\n      }\n      // add here\n      if (child.node.type === 'object3D') {\n        this.scene.add(child.object3D)\n      }\n      if (child.node.type === 'drawable') {\n        this.scene.add(child.drawable)\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "confirmRecylce": false
    },
    {
      "_id": "_317698",
      "title": "About Us Scene",
      "to": "_29338",
      "pos": {
        "x": 440,
        "y": 410
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      scene: false\n    }\n  },\n  methods: {\n    init () {\n      this.scene = new THREE.Scene()\n      this.scene.background = new THREE.Color('#000000')\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'camera') {\n        this.components[this.node.to].$emit('addChild', { child })\n      }\n      // add here\n      if (child.node.type === 'object3D') {\n        this.scene.add(child.object3D)\n      }\n      if (child.node.type === 'drawable') {\n        this.scene.add(child.drawable)\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "scene",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "confirmRecylce": false
    },
    {
      "_id": "_455500",
      "title": "RotateView Camera",
      "to": "_793268",
      "pos": {
        "x": 440,
        "y": 80
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {},\n    timename: {},\n    timetracks: {}\n  },\n  data () {\n    return {\n      camera: false\n    }\n  },\n  methods: {\n    init () {\n      let fov = 75\n      let rect = this.$parent.$el.getBoundingClientRect()\n      let aspect = rect.width / rect.height\n      let near = 0.1\n      let far = 100000000000000\n\n      this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far)\n      this.camera.position.z = 500\n      this.camera.lookAt(0,0,0)\n\n      this.$emit('exec', () => {\n        let item = this.timetracks.find(t => t.title === this.node.title && t.progress > 0.001 && t.progress < 1)\n        if (item) {\n          let x = 100 * Math.sin(3.14159265 * 2 * item.progress)\n          let y = 100 * Math.cos(3.14159265 * 2 * item.progress)\n          this.camera.lookAt(x, y, 0)\n        }\n      });\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "camera",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "confirmRecylce": false,
      "trashed": false
    },
    {
      "_id": "_793268",
      "title": "Cameras",
      "to": "root",
      "pos": {
        "x": 260,
        "y": 135
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      object3D: false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  methods: {\n    init () {\n      this.object3D = new THREE.Object3D()\n    }\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      this.components[this.node.to].$emit('addChild', { child })\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "organiser",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "preventDelete": true,
      "confirmRecylce": false
    },
    {
      "_id": "_29338",
      "title": "Scenes",
      "to": "root",
      "pos": {
        "x": 260,
        "y": 410
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      object3D: false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  methods: {\n    init () {\n      this.object3D = new THREE.Object3D()\n    }\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      this.components[this.node.to].$emit('addChild', { child })\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "organiser",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "preventDelete": true,
      "confirmRecylce": false
    },
    {
      "_id": "_247335",
      "title": "Still Camera",
      "to": "_793268",
      "pos": {
        "x": 440,
        "y": 190
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {},\n    timename: {},\n    timetracks: {}\n  },\n  data () {\n    return {\n      camera: false\n    }\n  },\n  methods: {\n    init () {\n      let fov = 75\n      let rect = this.$parent.$el.getBoundingClientRect()\n      let aspect = rect.width / rect.height\n      let near = 0.1\n      let far = 100000000000000\n\n      this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far)\n      this.camera.position.z = 500\n      this.camera.lookAt(0,0,0)\n      \n      // this.$emit('exec', () => {\n      //   // use time track\n      //   let item = this.timetracks.find(t => t.title === this.node.title && t.progress > 0.001 && t.progress < 1)\n      //   if (item) {\n      //     this.camera.position.z = -50 + (item.progress) * 1000\n      //   }\n      // });\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "camera",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_871971",
      "title": "Contact Us Scene",
      "to": "_29338",
      "pos": {
        "x": 440,
        "y": 520
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      scene: false\n    }\n  },\n  methods: {\n    init () {\n      this.scene = new THREE.Scene()\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      // if camera then pass to parent\n      if (child.node.type === 'camera') {\n        this.components[this.node.to].$emit('addChild', { child })\n      }\n\n      // add here\n      if (child.node.type === 'object3D') {\n        this.scene.add(child.object3D)\n      }\n      if (child.node.type === 'drawable') {\n        this.scene.add(child.drawable)\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "scene",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "trashed": false,
      "confirmRecylce": false
    },
    {
      "_id": "_208728",
      "title": "Shadow Poster",
      "to": "homepage",
      "pos": {
        "x": 620,
        "y": 300
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      geo: false,\n      mat: false,\n      drawable: false\n    }\n  },\n  methods: {\n    init () {\n      // let geo = new THREE.BoxBufferGeometry(100, 100, 100, 20, 20);\n      // let mat = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.1 });\n      this.drawable = new THREE.Mesh()\n      this.drawable.visible = false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'material') {\n        this.drawable.material = child.material\n        this.material = child.material\n      }\n      if (child.node.type === 'geometry') {\n        this.drawable.geometry = child.geometry\n        this.geometry = child.geometry\n      }\n      if (this.geometry && this.material) {\n        this.drawable.visible = true\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "drawable",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_205188",
      "title": "Poster Geo",
      "to": "_208728",
      "pos": {
        "x": 800,
        "y": 245
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  methods: {\n    init () {\n      this.geometry = new THREE.PlaneBufferGeometry(400, 400, 32, 32)\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "geometry",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_967525",
      "title": "Golen Spikes",
      "to": "_317698",
      "pos": {
        "x": 620,
        "y": 410
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      geo: false,\n      mat: false,\n      drawable: false\n    }\n  },\n  methods: {\n    init () {\n      \n      let makeAPI = ({ renderer }) => {\n        var api = {}\n      \n        function prepIndexer (texture, SIZE) {\n          var pixels = texture.image.data\n          var p = 0\n          let max = SIZE * SIZE\n          for (var j = 0; j < max; j++) {\n            pixels[p + 0] = j\n            pixels[p + 1] = j / (max)\n            pixels[p + 2] = SIZE\n            pixels[p + 3] = 1.0\n            p += 4\n          }\n        }\n      \n        var ticker = 0\n        let SIZE = 192\n        \n        var gpuCompute = new GPUComputationRenderer(SIZE, SIZE, renderer)\n      \n        var indexerTexture = gpuCompute.createTexture()\n        prepIndexer(indexerTexture, SIZE)\n      \n        var pingTarget = gpuCompute.createRenderTarget()\n        var pongTarget = gpuCompute.createRenderTarget()\n      \n        let pingMat, pongMat;\n      \n        let displayV = `uniform sampler2D posTex;\n        uniform float pointSize;\n        uniform sampler2D indexerTexture;\n        uniform sampler2D audio;\n      \n        varying vec2 vUv;\n        uniform float time;\n        \n      \n        void main() {\n            vec4 info = texture2D(indexerTexture, uv);\n      \n            vec4 pos = texture2D(posTex, uv);\n            \n            vec4 audioT = texture2D(audio, uv);\n      \n            vec4 mvPosition = modelViewMatrix * vec4(pos.xyz + normalize(pos.xyz) * 3.0 * audioT.xyz * 1.0, 1.0);\n            vec4 outputPos = projectionMatrix * mvPosition;\n      \n            // outputPos.y = outputPos.y + sin(outputPos.y + time * 50.0) * sin(outputPos.y + time * 50.0);\n            // outputPos.x = outputPos.x + cos(outputPos.x + time * 50.0) * sin(outputPos.x + time * 50.0);\n      \n            vUv = uv;\n      \n            gl_Position = outputPos;\n            gl_PointSize = pointSize;\n        }\n        `\n      \n        let displayF = `\n        // uniform sampler2D posTex;\n      \n        uniform sampler2D picture;\n        uniform float opacity;\n      \n        uniform float time;\n          \n        uniform vec3 mainColor; \n          \n        varying vec2 vUv;\n      \n        void main() {\n            \n            vec2 screen = vec2(gl_FragCoord.x, gl_FragCoord.y) / resolution.xy;\n            \n            screen.y *= 16.0 / 9.0;\n            screen.y -= 16.0 / 9.0 * 0.75;\n            \n            screen.x -= 0.5;\n            \n            \n            // vec4 imgColor = texture2D(picture, (screen));\n            \n            gl_FragColor = vec4(mainColor, 1.0);\n        }\n        `\n        var defaultPingPong = `//\n        //THANK YOU for your support <3 \n        //\n        \n        #include <common>\n        precision highp sampler2D;\n        \n        //\n        //  Classic Perlin 3D Noise\n        //  by Stefan Gustavson\n        //\n        \n        vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n        vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n        \n        float cnoise(vec2 P){\n          vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n          vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n          Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n          vec4 ix = Pi.xzxz;\n          vec4 iy = Pi.yyww;\n          vec4 fx = Pf.xzxz;\n          vec4 fy = Pf.yyww;\n          vec4 i = permute(permute(ix) + iy);\n          vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n          vec4 gy = abs(gx) - 0.5;\n          vec4 tx = floor(gx + 0.5);\n          gx = gx - tx;\n          vec2 g00 = vec2(gx.x,gy.x);\n          vec2 g10 = vec2(gx.y,gy.y);\n          vec2 g01 = vec2(gx.z,gy.z);\n          vec2 g11 = vec2(gx.w,gy.w);\n          vec4 norm = 1.79284291400159 - 0.85373472095314 *\n              vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n          g00 *= norm.x;\n          g01 *= norm.y;\n          g10 *= norm.z;\n          g11 *= norm.w;\n          float n00 = dot(g00, vec2(fx.x, fy.x));\n          float n10 = dot(g10, vec2(fx.y, fy.y));\n          float n01 = dot(g01, vec2(fx.z, fy.z));\n          float n11 = dot(g11, vec2(fx.w, fy.w));\n          vec2 fade_xy = fade(Pf.xy);\n          vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n          float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n          return 2.3 * n_xy;\n        }\n        \n        #define M_PI 3.1415926535897932384626433832795\n        float atan2(in float y, in float x) {\n          bool xgty = (abs(x) > abs(y));\n          return mix(M_PI/2.0 - atan(x,y), atan(y,x), float(xgty));\n        }\n        \n        vec3 ballify (vec3 pos, float r) {\n          float az = atan2(pos.y, pos.x);\n          float el = atan2(pos.z, sqrt(pos.x * pos.x + pos.y * pos.y));\n          return vec3(\n            r * cos(el) * cos(az),\n            r * cos(el) * sin(az),\n            r * sin(el)\n          );\n        }\n        \n        vec3 fromBall(float r, float az, float el) {\n          return vec3(\n            r * cos(el) * cos(az),\n            r * cos(el) * sin(az),\n            r * sin(el)\n          );\n        }\n        \n        void toBall(vec3 pos, out float az, out float el) {\n          az = atan2(pos.y, pos.x);\n          el = atan2(pos.z, sqrt(pos.x * pos.x + pos.y * pos.y));\n        }\n        \n        mat3 rotateZ(float rad) {\n            float c = cos(rad);\n            float s = sin(rad);\n            return mat3(\n                c, s, 0.0,\n                -s, c, 0.0,\n                0.0, 0.0, 1.0\n            );\n        }\n        \n        mat3 rotateY(float rad) {\n            float c = cos(rad);\n            float s = sin(rad);\n            return mat3(\n                c, 0.0, -s,\n                0.0, 1.0, 0.0,\n                s, 0.0, c\n            );\n        }\n        \n        mat3 rotateX(float rad) {\n            float c = cos(rad);\n            float s = sin(rad);\n            return mat3(\n                1.0, 0.0, 0.0,\n                0.0, c, s,\n                0.0, -s, c\n            );\n        }\n        \n        // float Gravity(float z) {\n        //   float G, eZ;\n        //   const float ER = 6378150.0;\n        //   const float ER2 = 6378150.0 * 6378150.0;\n        //   eZ = ER + z;\n        //   G = 9.81 * ER2 / (eZ * eZ);\n        //   return G;\n        // }\n        \n        float constrain(float val, float min, float max) {\n            if (val < min) {\n                return min;\n            } else if (val > max) {\n                return max;\n            } else {\n                return val;\n            }\n        }\n        \n        vec3 getDiff (vec3 lastPos, vec3 mouse) {\n          vec3 diff = lastPos.xyz - mouse;\n          float distance = constrain(length(diff), 1.0, 5.0);\n          float strength = 1.0 / (distance * distance);\n        \n          diff = normalize(diff);\n          diff = diff * strength * -1.0;\n        \n          return diff;\n        }\n        \n        vec3 resDiff (in vec3 lastPos, in vec3 mouse) {\n          vec3 diff = lastPos - mouse;\n          diff = normalize(diff) * -1.0;\n          return diff;\n        }\n        \n        uniform float time;\n        uniform sampler2D lastTexture;\n        uniform sampler2D indexerTexture;\n        \n        uniform vec3 mouse;\n        \n        void main () {\n        \n          // @v@\n          // @.@\n        \n          vec2 uv = gl_FragCoord.xy / resolution.xy;\n        \n          vec4 indexer = texture2D(indexerTexture, uv);\n          vec4 lastPos = texture2D(lastTexture, uv);\n        \n          float i = indexer.x;\n          float e = indexer.y;\n          float u = indexer.z;\n        \n          vec3 nextPos = vec3(lastPos);\n        \n          float x = 0.5 - rand(uv + .1);\n          float y = 0.5 - rand(uv + .2);\n          float z = 0.5 - rand(uv + .3);\n          \n          vec3 randomBall = ballify(vec3(x, y, z) + mouse, 1.0);\n          \n          vec3 pt1 = ballify(randomBall + nextPos, 15.0);\n          pt1.z += cnoise(pt1.xy + time * 20.0) * 6.0;\n          \n          \n          vec3 pt2 = ballify(randomBall + nextPos, 15.0);\n          pt2.z += rand(pt2.xy + time * 20.0);\n          \n          \n          nextPos = mix(pt1, pt2, smoothstep(0.0, 1.0, abs(distance(mouse, vec3(0.0))) / 0.5));\n          nextPos += getDiff(nextPos, mouse * 17.0) * 50.0;\n          \n          // remix code end here//\n          gl_FragColor = vec4(nextPos, 1.0);\n        }\n\n      \n        `\n      \n      \n      \n        let mouseV3 = new THREE.Vector3(0.0, 0.0, 0.0);\n      \n        let init = ({ pingPongShader }) => {\n          try {\n            let newPingMat = gpuCompute.createShaderMaterial(pingPongShader, {\n              lastTexture: { value: null },\n              indexerTexture: { value: indexerTexture },\n              time: { value: 0 },\n              mouse: { value: mouseV3 }\n            })\n            let newPongMat = gpuCompute.createShaderMaterial(pingPongShader, {\n              lastTexture: { value: null },\n              indexerTexture: { value: indexerTexture },\n              time: { value: 0 },\n              mouse: { value: mouseV3 }\n            })   \n            pingMat = newPingMat\n            pongMat = newPongMat\n          } catch (e) {\n            console.error(e)    \n          }\n        }\n      \n        init({ pingPongShader: defaultPingPong })\n      \n      \n        // sim part\n        let procSim = () => {\n          pingMat.uniforms.lastTexture.value = pongTarget.texture\n          pongMat.uniforms.lastTexture.value = pingTarget.texture\n      \n          pingMat.uniforms.time.value = window.performance.now() * 0.0001\n          pongMat.uniforms.time.value = window.performance.now() * 0.0001\n        }\n        \n        let rect = renderer.domElement.getBoundingClientRect()\n        \n        // display part\n        var geometry = new THREE.PlaneBufferGeometry(1.0, 1.0, SIZE - 1, SIZE - 1)\n        var material = new THREE.ShaderMaterial({\n          // blending: THREE.AdditiveBlending,\n          // depthTest: false,\n          transparent: true,\n          depthWrite: false,\n          vertexShader: displayV,\n          fragmentShader: displayF,\n          defines: {\n            aspectRatio: `${Number(rect.width / rect.height).toFixed(1)}`,\n            resolution: 'vec2( ' + rect.width.toFixed(1) + ', ' + rect.height.toFixed(1) + ' )'\n          },\n          uniforms: {\n            mainColor: { value: new THREE.Color('#ff0000') },\n            time: { value: 0 },\n            opacity: { value: 0.5 },\n            posTex: { value: null },\n\n            indexerTexture: { value: indexerTexture },\n      \n            picture: { value: null },\n            audio: { value: null },\n            pointSize: { value: window.devicePixelRatio || 1.0 }\n          }\n        })\n      \n        var points = new THREE.Points(geometry, material)\n        // var points = ev.points = new THREE.Points(geometry, material)\n        points.matrixAutoUpdate = false\n        points.updateMatrix()\n        points.frustumCulled = false\n      \n        \n        api.compute = () => {\n          procSim();\n          \n          if (ticker % 2 === 0) {\n            gpuCompute.doRenderTarget(pongMat, pongTarget)\n          } else {\n            gpuCompute.doRenderTarget(pingMat, pingTarget)\n          }\n      \n          if (ticker % 2 === 0) {\n            material.uniforms.posTex.value = pongTarget.texture;\n          } else {\n            material.uniforms.posTex.value = pingTarget.texture;\n          }\n          ticker++\n          \n          if (api.video) {\n            material.uniforms.picture.value = api.video\n          }\n          \n          material.uniforms.time.value = window.performance.now() * 0.0001\n        }\n        api.uniforms = material.uniforms\n        api.renderable = points;\n        api.mouse = mouseV3;\n      \n        return api\n      }\n      \n      \n      \n      let tt = setInterval(() => {\n        let node = this.nodes.find(n => n.type === 'root') \n        if (node && this.components[node._id] && this.components[node._id].renderer) {\n          clearInterval(tt);\n          let renderer = this.components[node._id].renderer\n          let simAPI = makeAPI({ renderer });\n          this.$emit('exec', () => {\n            simAPI.compute()\n          });\n          \n          simAPI.uniforms.mainColor.value = new THREE.Color('#ffb100');\n          \n          let o3 = new THREE.Object3D();\n          o3.add(simAPI.renderable);\n          o3.scale.x = 20.0\n          o3.scale.y = 20.0\n          o3.scale.z = 20.0\n\n          this.drawable = o3;\n\n          this.$emit('ready', this)\n        }\n      }, 10)\n      \n      // let geo = new THREE.BoxBufferGeometry(100, 100, 100, 20, 20);\n      // let mat = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.1 });\n      // this.drawable = new THREE.Mesh()\n    }\n  },\n  mounted () {\n    this.init()\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'material') {\n        this.drawable.material = child.material\n        this.material = child.material\n      }\n      if (child.node.type === 'geometry') {\n        this.drawable.geometry = child.geometry\n        this.geometry = child.geometry\n      }\n      if (this.geometry && this.material) {\n        this.drawable.visible = true\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [
        {
          "_id": "_791665",
          "url": "https://igraph.effectnode.com/threejs/examples/js/GPUComputationRenderer.js"
        }
      ],
      "type": "drawable",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "confirmRecylce": false
    },
    {
      "_id": "_210166",
      "title": "Shake Material",
      "to": "_208728",
      "pos": {
        "x": 800,
        "y": 355
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {},\n    timetracks: {}\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  methods: {\n    init () {\n      let uniforms = {\n        aspect: {\n          value: 1\n        },\n        ttD: {\n          value: new THREE.TextureLoader().load('https://res.cloudinary.com/hslkngave/image/upload/v1559309484/a8uctpsnyjsdnampbmva.png', () => {\n            uniforms.aspect.value = uniforms.ttD.value.image.width / uniforms.ttD.value.image.height;\n            // uniforms.ttD.value.wrapS = THREE.RepeatWrapping;\n            // uniforms.ttD.value.wrapT = THREE.RepeatWrapping;\n          })\n        },\n        blur: {\n          value: new THREE.Vector2(0, 0)\n        },\n        shift: {\n          value: new THREE.Vector3(0, 0, 0)\n        }\n      };\n      // uniforms.ttD.value.wrapS = THREE.MirroredRepeatWrapping\n      // uniforms.ttD.value.wrapT = THREE.MirroredRepeatWrapping\n      \n      this.$emit('exec', () => {\n        uniforms.blur.value.x *= 0.75\n        uniforms.blur.value.y *= 0.75\n      })\n      \n      let rect = this.$parent.$parent.$el.getBoundingClientRect()\n      \n      window.addEventListener('resize', () => {\n        rect = this.$parent.$parent.$el.getBoundingClientRect()\n      })\n      \n      this.$parent.$parent.$el.addEventListener('mousemove', (ev) => {\n        let rootNode = this.nodes.find(n => n.type === 'root')\n        if (rootNode) {\n          let rootCompo = this.components[rootNode._id]\n          if (rootCompo.screen) {\n            uniforms.blur.value.x += ev.movementX * 2.0\n            uniforms.blur.value.y += -ev.movementY * 2.0\n            \n            uniforms.shift.value.x = (ev.pageX - window.innerWidth * 0.5) / window.innerWidth * rootCompo.screen.screenWidth\n            uniforms.shift.value.y = -(ev.pageY - window.innerHeight * 0.5) / window.innerHeight * rootCompo.screen.screenHeight\n          }\n        }\n      })\n      let h = {\n        ts: { x: 0, y: 0 },\n      }\n      this.$parent.$parent.$el.addEventListener('touchstart', (ev) => {\n        ev.preventDefault()\n        h.ts.x = ev.touches[0].pageX\n        h.ts.y = -ev.touches[0].pageY\n      })\n      this.$parent.$parent.$el.addEventListener('touchmove', (ev) => {\n        ev.preventDefault()\n        let rootNode = this.nodes.find(n => n.type === 'root')\n        if (rootNode) {\n          let rootCompo = this.components[rootNode._id]\n          if (rootCompo.screen) {\n            uniforms.shift.value.x = (ev.touches[0].pageX - window.innerWidth * 0.5) / window.innerWidth * 30.0\n            uniforms.shift.value.y = -(ev.touches[0].pageY - window.innerHeight * 0.5) / window.innerHeight * 30.0\n            \n            let delta = {\n              x: ev.touches[0].pageX - h.ts.x,\n              y: -ev.touches[0].pageY - h.ts.y\n            }\n            uniforms.blur.value.x += delta.x * 0.5\n            uniforms.blur.value.y += delta.y * 0.5\n            \n            uniforms.shift.value.x = (ev.touches[0].pageX - window.innerWidth * 0.5) / window.innerWidth * rootCompo.screen.screenWidth\n            uniforms.shift.value.y = -(ev.touches[0].pageY - window.innerHeight * 0.5) / window.innerHeight * rootCompo.screen.screenHeight\n            \n            delta.x = ev.touches[0].pageX\n            delta.y = ev.touches[0].pageY\n          }\n        }\n      })\n      \n      let mat = new THREE.ShaderMaterial({\n        transparent: true,\n        uniforms,\n        vertexShader: `\n          #include <common>\n          varying vec2 vUv;\n          uniform vec3 shift;\n          uniform float aspect;\n          \n          void main()\t{\n            // smaller\n            vUv = uv;\n            \n            vec3 nPos = position * 2.0;\n            if (aspect > 1.0) {\n              nPos.y /= aspect;\n            } else {\n              nPos.x *= aspect;\n            }\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( nPos + shift, 1.0 );\n          }\n        `,\n        fragmentShader: `\n          \n          bool shouldDraw (vec2 uv) {\n            if (uv.x < 0.001) {\n              return false;\n            }\n            if (uv.y < 0.001) {\n              return false;\n            }\n            if (uv.x > 0.999) {\n              return false;\n            }\n            if (uv.y > 0.999) {\n              return false;\n            }\n            return true;\n          }\n        \n          // https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/13.glsl\n          vec4 motionBlur(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n            vec4 color = vec4(0.0);\n            vec2 off1 = vec2(1.411764705882353) * direction;\n            vec2 off2 = vec2(3.2941176470588234) * direction;\n            vec2 off3 = vec2(5.176470588235294) * direction;\n            \n            vec2 newUV = uv * 2.0 - 0.5;\n            \n            if (shouldDraw((newUV))) {\n              color += texture2D(image, (newUV)) * 0.2969069646728344;\n            }\n            if (shouldDraw((newUV + (off1 / resolution)))) {\n              color += texture2D(image, (newUV + (off1 / resolution))) * 0.1964825501511404;\n            }\n            if (shouldDraw((newUV + 0.5 * (off1 / resolution)))) {\n              color += texture2D(image, (newUV + 0.5 * (off1 / resolution))) * 0.1964825501511404;\n            }\n            if (shouldDraw((newUV + (off2 / resolution)))) {\n              color += texture2D(image, (newUV + (off2 / resolution))) * 0.09447039785044732;\n            }\n            if (shouldDraw((newUV + 0.5 * (off2 / resolution)))) {\n              color += texture2D(image, (newUV + 0.5 * (off2 / resolution))) * 0.09447039785044732;\n            }\n            if (shouldDraw((newUV + (off3 / resolution)))) {\n              color += texture2D(image, (newUV + (off3 / resolution))) * 0.010381362401148057;\n            }\n            if (shouldDraw((newUV + 0.5 * (off3 / resolution)))) {\n              color += texture2D(image, (newUV + 0.5 * (off3 / resolution))) * 0.010381362401148057;\n            }\n            \n            return color;\n          }\n          \n          uniform highp sampler2D ttD;\n          uniform vec2 blur;\n          varying highp vec2 vUv;\n          void main (void) {\n            // vec4 cColor = texture2D(ttD, vUv);\n            vec4 cColor = vec4(0.0);\n            \n            cColor = motionBlur(ttD, vUv, vec2(1024.0, 1024.0), vec2(blur.xy));\n            gl_FragColor = vec4(cColor.rgba);\n          }\n        `\n      });\n      this.material = mat\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      // if (child.node.type === 'map') {\n      //   this.material.map = child.map\n      // }\n      // if (child.node.type === 'geometry') {\n      //   this.material.geometry = child.geometry\n      // }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "material",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_53430",
      "title": "Mesh",
      "to": "_871971",
      "trashed": false,
      "pos": {
        "x": 620,
        "y": 520
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      geo: false,\n      mat: false,\n      drawable: false\n    }\n  },\n  methods: {\n    init () {\n      // let geo = new THREE.BoxBufferGeometry(100, 100, 100, 20, 20);\n      // let mat = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.1 });\n      this.drawable = new THREE.Mesh()\n      this.drawable.visible = false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'material') {\n        this.drawable.material = child.material\n        this.material = child.material\n      }\n      if (child.node.type === 'geometry') {\n        this.drawable.geometry = child.geometry\n        this.geometry = child.geometry\n      }\n      if (this.geometry && this.material) {\n        this.drawable.visible = true\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "drawable",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_662033",
      "title": "Sphere Geometry",
      "to": "_53430",
      "trashed": false,
      "pos": {
        "x": 800,
        "y": 465
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  methods: {\n    init () {\n      this.geometry = new THREE.SphereGeometry(256, 32, 32)\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "geometry",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_514827",
      "title": "MatCap Material",
      "to": "_53430",
      "trashed": false,
      "pos": {
        "x": 800,
        "y": 575
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  methods: {\n    init () {\n      let url = ''\n      url = `https://raw.githubusercontent.com/mykimbui/matcap/master/matcap.png`\n      // url = `https://raw.githubusercontent.com/mykimbui/matcap/master/matcap2.png`\n      let matcap = new THREE.TextureLoader().load(url, () => {\n        // matcap.encoding = THREE.sRGBEncoding;\n      })\n      let mat = new THREE.MeshMatcapMaterial({ color: 0xffffff, matcap });\n      this.material = mat\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      // if (child.node.type === 'map') {\n      //   this.material.map = child.map\n      // }\n      // if (child.node.type === 'geometry') {\n      //   this.material.geometry = child.geometry\n      // }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "material",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "confirmRecylce": false
    }
  ],
  "timeline": {
    "totalTime": "30",
    "tracks": [
      {
        "_id": "_91814940643",
        "start": 0,
        "end": 8.488372093023205,
        "title": "Home Scene",
        "trashed": false
      },
      {
        "_id": "_54214377498",
        "start": 8.302325581395356,
        "end": 17.593023255813954,
        "title": "About Us Scene",
        "trashed": false
      },
      {
        "_id": "_63844190752",
        "start": 17.37209302325581,
        "end": 30.04651162790697,
        "title": "Contact Us Scene",
        "trashed": false
      },
      {
        "_id": "_42591864702",
        "start": 2.3175905639050143e-15,
        "end": 8.313953488372071,
        "title": "RotateView Camera",
        "trashed": false
      },
      {
        "_id": "_89730102779",
        "start": 8.232558139534902,
        "end": 17.593023255813932,
        "title": "Still Camera",
        "trashed": false
      },
      {
        "_id": "_1172490259",
        "start": 17.33720930232559,
        "end": 30.081395348837216,
        "title": "RotateView Camera",
        "trashed": false
      }
    ]
  },
  "timeinfo": {
    "start": 0,
    "totalTime": "30",
    "timelinePlaying": true,
    "timelineControl": "timer",
    "timelinePercentageLast": 0,
    "timelinePercentage": 0,
    "loop": true,
    "elapsed": 0
  }
}