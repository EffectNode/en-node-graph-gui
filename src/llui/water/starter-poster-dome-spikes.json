{
  "nodes": [
    {
      "_id": "root",
      "title": "Your App Home",
      "protected": true,
      "cannotDrop": true,
      "acceptDrop": [
        "pages"
      ],
      "isRoot": true,
      "type": "root",
      "to": null,
      "pos": {
        "x": 80,
        "y": 245
      },
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "src": "<template>\n  <div class=\"full\" ref=\"mounter\">\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    nodes: {},\n    \n    components: {},\n    timename: {},\n    timetracks: {}\n  },\n  data () {\n    return {\n      screen: false,\n      syncAll: {},\n      cameras: {},\n      scenes: {},\n      \n      sceneID: '',\n      cameraID: '',\n      \n      mouse: { x: 0, y: 0 },\n      renderer: false\n    }\n  },\n  watch: {\n    cameraID () {\n      window.dispatchEvent(new Event('resize'))\n      this.getSizeInfo()\n      this.syncAll()\n      this.syncScreen()\n    }\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'camera') {\n        this.cameras[child.node._id] = child.camera\n        window.dispatchEvent(new Event('resize'))\n      }\n      if (child.node.type === 'scene') {\n        this.scenes[child.node._id] = child.scene\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestroy () {\n    this.stop()\n    this.$emit('remove', this)\n  },\n  mounted () {\n    // let sceneIDs = this.nodes.filter(t => t.type === 'scene').map(t => t._id)\n    // let cameraIDs = this.nodes.filter(t => t.type === 'camera').map(t => t._id)\n    // this.cameraID = cameraIDs[0]\n    // this.sceneID = sceneIDs[0]\n    this.init()\n  },\n  methods: {\n    init () {\n      this.setupRenderer()\n      this.getSizeInfo()\n      this.setupSizer()\n      this.syncSize()\n      this.start()\n      this.$emit('ready', this)\n    },\n    syncScreen () {\n      let camera = this.cameras[this.cameraID]\n      if (camera) {\n        let depth = 0\n        var aspect = camera.aspect\n        var dist = camera.position.z - (depth) // item\n        var vFOV = THREE.Math.degToRad(camera.fov) // convert vertical fov to radians\n        var screenHeight = 2 * Math.tan(vFOV / 2) * dist // visible height\n        var screenWidth = screenHeight * aspect // visible width\n        this.screen = {\n          aspect,\n          dist,\n          vFOV,\n          screenWidth,\n          screenHeight\n        }\n      }\n    },\n    setupRenderer () {\n      this.renderer = new THREE.WebGLRenderer({\n        antialias: true,\n        alpha: true,\n        preserveDrawingBuffer: true\n      })\n      this.renderer.domElement.style.marginBottom = '-6px'\n      this.$refs['mounter'].appendChild(this.renderer.domElement)\n    },\n    setupSizer () {\n      this.getSizeInfo()\n      window.addEventListener('resize', this.getSizeInfo, false)\n    },\n    getSizeInfo () {\n      if (!this.$refs['mounter']) {\n        return\n      }\n      var rect = this.$refs['mounter'].getBoundingClientRect()\n      this.rect = rect\n      this.size = {\n        width: rect.width,\n        height: rect.height,\n        aspect: rect.width / rect.height\n      }\n      this.dpi = 2.0 // window.devicePixelRatio || 1.0\n    },\n    syncSize () {\n      let sync = () => {\n        let { composer, cameras, renderer, size, dpi, control } = this\n        let camera = cameras[this.cameraID]\n        if (control) {\n          control.update()\n        }\n        if (composer) {\n          composer.setSize(size.width * dpi, size.height * dpi)\n        }\n        \n        renderer.setPixelRatio(dpi)\n        renderer.setSize(size.width, size.height)\n        if (camera) {\n          camera.aspect = size.width / size.height\n          camera.updateProjectionMatrix()\n        }\n        this.syncScreen()\n      }\n      \n      sync()\n      this.syncAll = () => {\n        sync()\n      }\n      window.addEventListener('resize', sync, false)\n\n      this.$refs['mounter'].addEventListener('mousemove', (evt) => {\n        this.mouse.x = evt.pageX\n        this.mouse.y = evt.pageY\n      }, false)\n    },\n    stop () {\n      window.cancelAnimationFrame(this.rAFID)\n    },\n    start () {\n      let rAF = () => {\n        this.rAFID = window.requestAnimationFrame(rAF)\n        this.render()\n      }\n      this.rAFID = window.requestAnimationFrame(rAF)\n    },\n    resolveSwitchableArray () {\n      this.timetracks.filter(track => track.progress > 0.0001 && track.progress < 1).forEach((track) => {\n        let item = this.nodes.find(n => n.title === track.title)\n        \n        if (item && item._id) {\n          if (item.type === 'camera') {\n            this.cameraID = item._id\n          } else if (item.type === 'scene') {\n            this.sceneID = item._id\n          }\n        }\n      })\n    },\n    // resolveSwitchable () {\n    // for (var kn in this.timename) {\n    //     if (this.timename[kn] > 0.001 && this.timename[kn] < 1) {\n    //       let item = this.nodes.find(n => n.title === kn)\n    //       if (item && item._id) {\n    //         if (item.type === 'camera') {\n    //           this.cameraID = item._id\n    //           // console.log('use cam ->', item.title)\n    //           // if (this.cameraID !== item._id) {\n    //           //   // window.dispatchEvent(new Event('resize'))\n    //           // }\n    //         } else if (item.type === 'scene') {\n    //           this.sceneID = item._id\n    //           // if (this.sceneID !== item._id) {\n    //           //   // console.log('use scene ->', item.title)\n    //           // }\n    //         }\n    //       }\n    //     }\n    //   }\n    // },\n    render () {\n      let { scenes, cameras, renderer, composer } = this\n      // this.resolveSwitchable()\n      this.resolveSwitchableArray()\n      \n      let scene = scenes[this.sceneID]\n      let camera = cameras[this.cameraID]\n\n      if (scene && camera && renderer && composer) {\n        composer.render()\n      } else if (scene && camera && renderer) {\n        renderer.render(scene, camera)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "sceneID": "homepage",
      "cameraID": "_455500",
      "cannotDelete": false,
      "preventDelete": true,
      "confirmRecylce": false
    },
    {
      "_id": "homepage",
      "title": "Home Scene",
      "protected": true,
      "type": "scene",
      "to": "_29338",
      "pos": {
        "x": 440,
        "y": 300
      },
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "library": [],
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      scene: false\n    }\n  },\n  methods: {\n    init () {\n      this.scene = new THREE.Scene()\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'camera') {\n        this.components[this.node.to].$emit('addChild', { child })\n      }\n      // add here\n      if (child.node.type === 'object3D') {\n        this.scene.add(child.object3D)\n      }\n      if (child.node.type === 'drawable') {\n        this.scene.add(child.drawable)\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "confirmRecylce": false,
      "showDeveloper": true
    },
    {
      "_id": "_317698",
      "title": "About Us Scene",
      "to": "_29338",
      "pos": {
        "x": 440,
        "y": 410
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      scene: false\n    }\n  },\n  methods: {\n    init () {\n      this.scene = new THREE.Scene()\n      this.scene.background = new THREE.Color(`#000000`)\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'camera') {\n        this.components[this.node.to].$emit('addChild', { child })\n      }\n      // add here\n      if (child.node.type === 'object3D') {\n        this.scene.add(child.object3D)\n      }\n      if (child.node.type === 'drawable') {\n        this.scene.add(child.drawable)\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "scene",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "confirmRecylce": false
    },
    {
      "_id": "_455500",
      "title": "RotateView Camera",
      "to": "_793268",
      "pos": {
        "x": 440,
        "y": 80
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {},\n    timename: {},\n    timetracks: {}\n  },\n  data () {\n    return {\n      camera: false\n    }\n  },\n  methods: {\n    init () {\n      let fov = 75\n      let rect = this.$parent.$el.getBoundingClientRect()\n      let aspect = rect.width / rect.height\n      let near = 0.1\n      let far = 100000000000000\n\n      this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far)\n      this.camera.position.z = 500\n      this.camera.lookAt(0,0,0)\n\n      this.$emit('exec', () => {\n        let item = this.timetracks.find(t => t.title === this.node.title && t.progress > 0.001 && t.progress < 1)\n        if (item) {\n          let x = 100 * Math.sin(3.14159265 * 2 * item.progress)\n          let y = 100 * Math.cos(3.14159265 * 2 * item.progress)\n          this.camera.lookAt(x, y, 0)\n        }\n      });\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "camera",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "confirmRecylce": false,
      "trashed": false
    },
    {
      "_id": "_793268",
      "title": "Cameras",
      "to": "root",
      "pos": {
        "x": 260,
        "y": 135
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      object3D: false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  methods: {\n    init () {\n      this.object3D = new THREE.Object3D()\n    }\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      this.components[this.node.to].$emit('addChild', { child })\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "organiser.camera",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "preventDelete": true,
      "confirmRecylce": false,
      "hideRecycle": true,
      "cannotChangeTitle": true
    },
    {
      "_id": "_29338",
      "title": "Scenes",
      "to": "root",
      "pos": {
        "x": 260,
        "y": 410
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      object3D: false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  methods: {\n    init () {\n      this.object3D = new THREE.Object3D()\n    }\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      this.components[this.node.to].$emit('addChild', { child })\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "organiser.scene",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "preventDelete": true,
      "confirmRecylce": false,
      "hideRecycle": true,
      "cannotChangeTitle": true
    },
    {
      "_id": "_247335",
      "title": "Still Camera",
      "to": "_793268",
      "pos": {
        "x": 440,
        "y": 190
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {},\n    timename: {},\n    timetracks: {}\n  },\n  data () {\n    return {\n      camera: false\n    }\n  },\n  methods: {\n    init () {\n      let fov = 75\n      let rect = this.$parent.$el.getBoundingClientRect()\n      let aspect = rect.width / rect.height\n      let near = 0.1\n      let far = 100000000000000\n\n      this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far)\n      this.camera.position.z = 500\n      this.camera.lookAt(0,0,0)\n      \n      // this.$emit('exec', () => {\n      //   // use time track\n      //   let item = this.timetracks.find(t => t.title === this.node.title && t.progress > 0.001 && t.progress < 1)\n      //   if (item) {\n      //     this.camera.position.z = -50 + (item.progress) * 1000\n      //   }\n      // });\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "camera",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_871971",
      "title": "Contact Us Scene",
      "to": "_29338",
      "pos": {
        "x": 440,
        "y": 520
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      scene: false\n    }\n  },\n  methods: {\n    init () {\n      this.scene = new THREE.Scene()\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      // if camera then pass to parent\n      if (child.node.type === 'camera') {\n        this.components[this.node.to].$emit('addChild', { child })\n      }\n\n      // add here\n      if (child.node.type === 'object3D') {\n        this.scene.add(child.object3D)\n      }\n      if (child.node.type === 'drawable') {\n        this.scene.add(child.drawable)\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "scene",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "trashed": false,
      "confirmRecylce": false
    },
    {
      "_id": "_208728",
      "title": "Poster",
      "to": "homepage",
      "pos": {
        "x": 620,
        "y": 300
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      geo: false,\n      mat: false,\n      drawable: false\n    }\n  },\n  methods: {\n    init () {\n      // let geo = new THREE.BoxBufferGeometry(100, 100, 100, 20, 20);\n      // let mat = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.1 });\n      let map = new THREE.TextureLoader().load(`https://res.cloudinary.com/hslkngave/image/upload/v1559309484/a8uctpsnyjsdnampbmva.png`)\n      this.drawable = new THREE.Mesh()\n      this.drawable.geometry = new THREE.PlaneBufferGeometry(500, 500, 2, 2);\n      this.drawable.material = new THREE.MeshBasicMaterial({ color: new THREE.Color(0xffffff),  map })\n      this.drawable.visible = true\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'material') {\n        this.drawable.material = child.material\n        this.material = child.material\n      }\n      if (child.node.type === 'geometry') {\n        this.drawable.geometry = child.geometry\n        this.geometry = child.geometry\n      }\n      if (this.geometry && this.material) {\n        this.drawable.visible = true\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "drawable",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false,
      "preventDelete": false
    },
    {
      "_id": "_967525",
      "title": "Golen Spikes",
      "to": "_317698",
      "pos": {
        "x": 620,
        "y": 410
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      geo: false,\n      mat: false,\n      drawable: false\n    }\n  },\n  methods: {\n    init () {\n      \n      let makeAPI = ({ renderer }) => {\n        var api = {}\n      \n        function prepIndexer (texture, SIZE) {\n          var pixels = texture.image.data\n          var p = 0\n          let max = SIZE * SIZE\n          for (var j = 0; j < max; j++) {\n            pixels[p + 0] = j\n            pixels[p + 1] = j / (max)\n            pixels[p + 2] = SIZE\n            pixels[p + 3] = 1.0\n            p += 4\n          }\n        }\n      \n        var ticker = 0\n        let SIZE = 192\n        \n        var gpuCompute = new GPUComputationRenderer(SIZE, SIZE, renderer)\n      \n        var indexerTexture = gpuCompute.createTexture()\n        prepIndexer(indexerTexture, SIZE)\n      \n        var pingTarget = gpuCompute.createRenderTarget()\n        var pongTarget = gpuCompute.createRenderTarget()\n      \n        let pingMat, pongMat;\n      \n        let displayV = `uniform sampler2D posTex;\n        uniform float pointSize;\n        uniform sampler2D indexerTexture;\n        uniform sampler2D audio;\n      \n        varying vec2 vUv;\n        uniform float time;\n        \n      \n        void main() {\n            vec4 info = texture2D(indexerTexture, uv);\n      \n            vec4 pos = texture2D(posTex, uv);\n            \n            vec4 audioT = texture2D(audio, uv);\n      \n            vec4 mvPosition = modelViewMatrix * vec4(pos.xyz + normalize(pos.xyz) * 3.0 * audioT.xyz * 1.0, 1.0);\n            vec4 outputPos = projectionMatrix * mvPosition;\n      \n            // outputPos.y = outputPos.y + sin(outputPos.y + time * 50.0) * sin(outputPos.y + time * 50.0);\n            // outputPos.x = outputPos.x + cos(outputPos.x + time * 50.0) * sin(outputPos.x + time * 50.0);\n      \n            vUv = uv;\n      \n            gl_Position = outputPos;\n            gl_PointSize = 1.0;\n        }\n        `\n      \n        let displayF = `\n        // uniform sampler2D posTex;\n      \n        uniform sampler2D picture;\n        uniform float opacity;\n      \n        uniform float time;\n          \n        uniform vec3 mainColor; \n          \n        varying vec2 vUv;\n      \n        void main() {\n            \n            vec2 screen = vec2(gl_FragCoord.x, gl_FragCoord.y) / resolution.xy;\n            \n            screen.y *= 16.0 / 9.0;\n            screen.y -= 16.0 / 9.0 * 0.75;\n            \n            screen.x -= 0.5;\n            \n            \n            // vec4 imgColor = texture2D(picture, (screen));\n            \n            gl_FragColor = vec4(mainColor, 1.0);\n        }\n        `\n        var defaultPingPong = `//\n        //THANK YOU for your support <3 \n        //\n        \n        #include <common>\n        precision highp sampler2D;\n        \n        //\n        //  Classic Perlin 3D Noise\n        //  by Stefan Gustavson\n        //\n        \n        vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n        vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n        \n        float cnoise(vec2 P){\n          vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n          vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n          Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n          vec4 ix = Pi.xzxz;\n          vec4 iy = Pi.yyww;\n          vec4 fx = Pf.xzxz;\n          vec4 fy = Pf.yyww;\n          vec4 i = permute(permute(ix) + iy);\n          vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n          vec4 gy = abs(gx) - 0.5;\n          vec4 tx = floor(gx + 0.5);\n          gx = gx - tx;\n          vec2 g00 = vec2(gx.x,gy.x);\n          vec2 g10 = vec2(gx.y,gy.y);\n          vec2 g01 = vec2(gx.z,gy.z);\n          vec2 g11 = vec2(gx.w,gy.w);\n          vec4 norm = 1.79284291400159 - 0.85373472095314 *\n              vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n          g00 *= norm.x;\n          g01 *= norm.y;\n          g10 *= norm.z;\n          g11 *= norm.w;\n          float n00 = dot(g00, vec2(fx.x, fy.x));\n          float n10 = dot(g10, vec2(fx.y, fy.y));\n          float n01 = dot(g01, vec2(fx.z, fy.z));\n          float n11 = dot(g11, vec2(fx.w, fy.w));\n          vec2 fade_xy = fade(Pf.xy);\n          vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n          float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n          return 2.3 * n_xy;\n        }\n        \n        #define M_PI 3.1415926535897932384626433832795\n        float atan2(in float y, in float x) {\n          bool xgty = (abs(x) > abs(y));\n          return mix(M_PI/2.0 - atan(x,y), atan(y,x), float(xgty));\n        }\n        \n        vec3 ballify (vec3 pos, float r) {\n          float az = atan2(pos.y, pos.x);\n          float el = atan2(pos.z, sqrt(pos.x * pos.x + pos.y * pos.y));\n          return vec3(\n            r * cos(el) * cos(az),\n            r * cos(el) * sin(az),\n            r * sin(el)\n          );\n        }\n        \n        vec3 fromBall(float r, float az, float el) {\n          return vec3(\n            r * cos(el) * cos(az),\n            r * cos(el) * sin(az),\n            r * sin(el)\n          );\n        }\n        \n        void toBall(vec3 pos, out float az, out float el) {\n          az = atan2(pos.y, pos.x);\n          el = atan2(pos.z, sqrt(pos.x * pos.x + pos.y * pos.y));\n        }\n        \n        mat3 rotateZ(float rad) {\n            float c = cos(rad);\n            float s = sin(rad);\n            return mat3(\n                c, s, 0.0,\n                -s, c, 0.0,\n                0.0, 0.0, 1.0\n            );\n        }\n        \n        mat3 rotateY(float rad) {\n            float c = cos(rad);\n            float s = sin(rad);\n            return mat3(\n                c, 0.0, -s,\n                0.0, 1.0, 0.0,\n                s, 0.0, c\n            );\n        }\n        \n        mat3 rotateX(float rad) {\n            float c = cos(rad);\n            float s = sin(rad);\n            return mat3(\n                1.0, 0.0, 0.0,\n                0.0, c, s,\n                0.0, -s, c\n            );\n        }\n        \n        // float Gravity(float z) {\n        //   float G, eZ;\n        //   const float ER = 6378150.0;\n        //   const float ER2 = 6378150.0 * 6378150.0;\n        //   eZ = ER + z;\n        //   G = 9.81 * ER2 / (eZ * eZ);\n        //   return G;\n        // }\n        \n        float constrain(float val, float min, float max) {\n            if (val < min) {\n                return min;\n            } else if (val > max) {\n                return max;\n            } else {\n                return val;\n            }\n        }\n        \n        vec3 getDiff (vec3 lastPos, vec3 mouse) {\n          vec3 diff = lastPos.xyz - mouse;\n          float distance = constrain(length(diff), 1.0, 5.0);\n          float strength = 1.0 / (distance * distance);\n        \n          diff = normalize(diff);\n          diff = diff * strength * -1.0;\n        \n          return diff;\n        }\n        \n        vec3 resDiff (in vec3 lastPos, in vec3 mouse) {\n          vec3 diff = lastPos - mouse;\n          diff = normalize(diff) * -1.0;\n          return diff;\n        }\n        \n        uniform float time;\n        uniform sampler2D lastTexture;\n        uniform sampler2D indexerTexture;\n        \n        uniform vec3 mouse;\n        \n        void main () {\n        \n          // @v@\n          // @.@\n        \n          vec2 uv = gl_FragCoord.xy / resolution.xy;\n        \n          vec4 indexer = texture2D(indexerTexture, uv);\n          vec4 lastPos = texture2D(lastTexture, uv);\n        \n          float i = indexer.x;\n          float e = indexer.y;\n          float u = indexer.z;\n        \n          vec3 nextPos = vec3(lastPos);\n        \n          float x = 0.5 - rand(uv + .1);\n          float y = 0.5 - rand(uv + .2);\n          float z = 0.5 - rand(uv + .3);\n          \n          vec3 randomBall = ballify(vec3(x, y, z) + mouse, 1.0);\n          \n          vec3 pt1 = ballify(randomBall + nextPos, 15.0);\n          pt1.z += cnoise(pt1.xy + time * 20.0) * 6.0;\n          \n          \n          vec3 pt2 = ballify(randomBall + nextPos, 15.0);\n          pt2.z += rand(pt2.xy + time * 20.0);\n          \n          \n          nextPos = mix(pt1, pt2, smoothstep(0.0, 1.0, abs(distance(mouse, vec3(0.0))) / 0.5));\n          nextPos += getDiff(nextPos, mouse * 17.0) * 50.0;\n          \n          // remix code end here//\n          gl_FragColor = vec4(nextPos, 1.0);\n        }\n\n      \n        `\n      \n      \n      \n        let mouseV3 = new THREE.Vector3(0.0, 0.0, 0.0);\n      \n        let init = ({ pingPongShader }) => {\n          try {\n            let newPingMat = gpuCompute.createShaderMaterial(pingPongShader, {\n              lastTexture: { value: null },\n              indexerTexture: { value: indexerTexture },\n              time: { value: 0 },\n              mouse: { value: mouseV3 }\n            })\n            let newPongMat = gpuCompute.createShaderMaterial(pingPongShader, {\n              lastTexture: { value: null },\n              indexerTexture: { value: indexerTexture },\n              time: { value: 0 },\n              mouse: { value: mouseV3 }\n            })   \n            pingMat = newPingMat\n            pongMat = newPongMat\n          } catch (e) {\n            console.error(e)    \n          }\n        }\n      \n        init({ pingPongShader: defaultPingPong })\n      \n      \n        // sim part\n        let procSim = () => {\n          pingMat.uniforms.lastTexture.value = pongTarget.texture\n          pongMat.uniforms.lastTexture.value = pingTarget.texture\n      \n          pingMat.uniforms.time.value = window.performance.now() * 0.0001\n          pongMat.uniforms.time.value = window.performance.now() * 0.0001\n        }\n        \n        let rect = renderer.domElement.getBoundingClientRect()\n        \n        // display part\n        var geometry = new THREE.PlaneBufferGeometry(1.0, 1.0, SIZE - 1, SIZE - 1)\n        var material = new THREE.ShaderMaterial({\n          // blending: THREE.AdditiveBlending,\n          // depthTest: false,\n          transparent: true,\n          depthWrite: false,\n          vertexShader: displayV,\n          fragmentShader: displayF,\n          defines: {\n            aspectRatio: `${Number(rect.width / rect.height).toFixed(1)}`,\n            resolution: 'vec2( ' + rect.width.toFixed(1) + ', ' + rect.height.toFixed(1) + ' )'\n          },\n          uniforms: {\n            mainColor: { value: new THREE.Color('#ff0000') },\n            time: { value: 0 },\n            opacity: { value: 0.5 },\n            posTex: { value: null },\n\n            indexerTexture: { value: indexerTexture },\n      \n            picture: { value: null },\n            audio: { value: null },\n            pointSize: { value: window.devicePixelRatio || 1.0 }\n          }\n        })\n      \n        var points = new THREE.Points(geometry, material)\n        // var points = ev.points = new THREE.Points(geometry, material)\n        points.matrixAutoUpdate = false\n        points.updateMatrix()\n        points.frustumCulled = false\n      \n        \n        api.compute = () => {\n          procSim();\n          \n          if (ticker % 2 === 0) {\n            gpuCompute.doRenderTarget(pongMat, pongTarget)\n          } else {\n            gpuCompute.doRenderTarget(pingMat, pingTarget)\n          }\n      \n          if (ticker % 2 === 0) {\n            material.uniforms.posTex.value = pongTarget.texture;\n          } else {\n            material.uniforms.posTex.value = pingTarget.texture;\n          }\n          ticker++\n          \n          if (api.video) {\n            material.uniforms.picture.value = api.video\n          }\n          \n          material.uniforms.time.value = window.performance.now() * 0.0001\n        }\n        api.uniforms = material.uniforms\n        api.renderable = points;\n        api.mouse = mouseV3;\n      \n        return api\n      }\n      \n      \n      \n      let tt = setInterval(() => {\n        let node = this.nodes.find(n => n.type === 'root') \n        if (node && this.components[node._id] && this.components[node._id].renderer) {\n          clearInterval(tt);\n          let renderer = this.components[node._id].renderer\n          let simAPI = makeAPI({ renderer });\n          this.$emit('exec', () => {\n            simAPI.compute()\n          });\n          \n          simAPI.uniforms.mainColor.value = new THREE.Color('#ffc100');\n          \n          let o3 = new THREE.Object3D();\n          o3.add(simAPI.renderable);\n          o3.scale.x = 20.0\n          o3.scale.y = 20.0\n          o3.scale.z = 20.0\n\n          this.drawable = o3;\n\n          this.$emit('ready', this)\n        }\n      }, 10)\n      \n      // let geo = new THREE.BoxBufferGeometry(100, 100, 100, 20, 20);\n      // let mat = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.1 });\n      // this.drawable = new THREE.Mesh()\n    }\n  },\n  mounted () {\n    this.init()\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'material') {\n        this.drawable.material = child.material\n        this.material = child.material\n      }\n      if (child.node.type === 'geometry') {\n        this.drawable.geometry = child.geometry\n        this.geometry = child.geometry\n      }\n      if (this.geometry && this.material) {\n        this.drawable.visible = true\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [
        {
          "_id": "_791665",
          "url": "https://igraph.effectnode.com/threejs/examples/js/GPUComputationRenderer.js"
        }
      ],
      "type": "drawable",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "confirmRecylce": false,
      "preventDelete": false,
      "showDeveloper": false
    },
    {
      "_id": "_692",
      "title": "Dome",
      "to": "_871971",
      "trashed": false,
      "pos": {
        "x": 620,
        "y": 520
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {},\n    timetracks: {},\n    timename: {},\n    tmeinfo: {}\n  },\n  data () {\n    return {\n    }\n  },\n  methods: {\n    init () {\n      let EventDispatcher = THREE.EventDispatcher\n            \n      class Plane {\n        constructor ({ link, at }) {\n          let size = 230\n          this.geo = new THREE.PlaneBufferGeometry(size, size, 128, 128)\n          let texture = new THREE.TextureLoader().load(link)\n          this.material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, map: texture, side: THREE.BackSide })\n          this.mesh = new THREE.Mesh(this.geo, this.material)\n      \n          this.group = new THREE.Object3D()\n          this.group.add(this.mesh)\n          if (at === 'px') {\n            this.group.position.x = size * 0.5 * 1.0\n            this.group.rotation.y = Math.PI * 0.5 * 1.0\n          } else if (at === 'nx') {\n            this.group.position.x = size * 0.5 * -1.0\n            this.group.rotation.y = Math.PI * 0.5 * -1.0\n          } else if (at === 'py') {\n            this.group.position.y = size * 0.5 * 1.0\n            this.group.rotation.x = Math.PI * 0.5 * -1.0\n          } else if (at === 'ny') {\n            this.group.position.y = size * 0.5 * -1.0\n            this.group.rotation.x = Math.PI * 0.5 * 1.0\n          } if (at === 'pz') {\n            this.group.position.z = size * 0.5 * 1.0\n            this.group.rotation.y = Math.PI * 0.5 * 4.0\n          } else if (at === 'nz') {\n            this.group.position.z = size * 0.5 * -1.0\n            this.group.rotation.y = Math.PI * 0.5 * -2.0\n          }\n        }\n      }\n      \n      class Sky {\n        constructor ({ links }) {\n          let group = new THREE.Object3D()\n          this.group = group\n      \n          this.fliper = new THREE.Object3D()\n          this.fliper.rotation.z = Math.PI\n          this.fliper.rotation.y = Math.PI\n          this.group.add(this.fliper)\n      \n          var at = [\n            'px',\n            'nx',\n      \n            'py',\n            'ny',\n      \n            'pz',\n            'nz'\n          ]\n      \n          this.planes = links.map((link, i) => {\n            let plane = new Plane({\n              link,\n              at: at[i]\n            })\n            return plane\n          })\n      \n          this.planes.forEach((plane) => {\n            this.fliper.add(plane.group)\n            return plane\n          })\n        }\n      }\n      \n      class Sphere {\n        constructor ({ envMap }) {\n          // // Create car\n          var geo = new THREE.SphereBufferGeometry(100, 100, 64, 64)\n          var material = new THREE.MeshBasicMaterial({ color: 0xffffff, envMap, side: THREE.BackSide })\n          var mesh = new THREE.Mesh(geo, material)\n          this.mesh = mesh\n          this.group = new THREE.Object3D()\n          this.group.add(mesh)\n        }\n      }\n      \n      class Universe extends EventDispatcher {\n        constructor ({ renderer, scene, links, resolution = 512 }) {\n          super()\n          this.renderer = renderer\n          this.scene = new THREE.Scene()\n      \n          this.group = new THREE.Object3D()\n      \n          // background skybox\n          this.backGroundGroup = new THREE.Object3D()\n          this.group.add(this.backGroundGroup)\n      \n          // visible object\n          this.foreGroundGroup = new THREE.Object3D()\n          this.group.add(this.foreGroundGroup)\n          \n      \n          this.sky = new Sky({\n            links\n          })\n          this.backGroundGroup.add(this.sky.group)\n\n\n      \n          this.cubecam = new THREE.CubeCamera(1, 3000, resolution)\n          this.group.add(this.cubecam)\n      \n          this.sphere = new Sphere({\n            envMap: this.cubecam.renderTarget.texture\n          })\n      \n          this.foreGroundGroup.add(this.sphere.group)\n      \n          this.animate = () => {\n      \n          }\n          this.scene.add(this.group)\n          \n          this.preCapture = () => {\n            this.backGroundGroup.visible = true\n            this.foreGroundGroup.visible = false\n          }\n          this.capture = () => {\n            this.animate()\n            this.cubecam.update(this.renderer, this.scene)\n          }\n          this.postCapture = () => {\n            this.backGroundGroup.visible = false\n            this.foreGroundGroup.visible = true\n          }\n        }\n      }\n      \n      let rootnode = this.nodes.find(no => no.type === 'root')\n      let rootCompo = this.components[rootnode._id]\n      \n      let pAPIs = new Universe({\n        renderer: rootCompo.renderer,\n        // scene: this.engine.scene,\n        links: [\n          `https://res.cloudinary.com/htdjnmcsz/image/upload/v1557820567/zngndtrninocunhymquz.png`,\n          `https://res.cloudinary.com/htdjnmcsz/image/upload/v1557820567/kpyurwejhva9yd65fsjk.png`,\n          `https://res.cloudinary.com/htdjnmcsz/image/upload/v1557820567/qrdjxy3xe5bxbuotsshz.png`,\n          `https://res.cloudinary.com/htdjnmcsz/image/upload/v1557820567/resdrnerd9n3fhjuxltv.png`,\n          `https://res.cloudinary.com/htdjnmcsz/image/upload/v1557820567/ta8ggppgiyiuwykkmnjc.png`,\n          `https://res.cloudinary.com/htdjnmcsz/image/upload/v1557820567/epuaxw3fkdvftl5pmfwv.png`\n          \n          // this.textures.px,\n          // this.textures.nx,\n          // this.textures.py,\n          // this.textures.ny,\n          // this.textures.pz,\n          // this.textures.nz          \n          \n          // require('../Universe/img/mplus-cubemap/v1/px.jpg'),\n          // require('../Universe/img/mplus-cubemap/v1/nx.jpg'),\n\n          // require('../Universe/img/mplus-cubemap/v1/py.jpg'),\n          // require('../Universe/img/mplus-cubemap/v1/ny.jpg'),\n\n          // require('../Universe/img/mplus-cubemap/v1/pz.jpg'),\n          // require('../Universe/img/mplus-cubemap/v1/nz.jpg')\n\n          // require('../Universe/img/home/px.jpg'),\n          // require('../Universe/img/home/nx.jpg'),\n\n          // require('../Universe/img/home/py.jpg'),\n          // require('../Universe/img/home/ny.jpg'),\n\n          // require('../Universe/img/home/pz.jpg'),\n          // require('../Universe/img/home/nz.jpg')\n        ],\n        resolution: 1024\n      });\n      \n      this.drawable = pAPIs.foreGroundGroup\n      \n      this.$emit('exec', () => {\n        pAPIs.preCapture();\n        pAPIs.capture();\n        pAPIs.postCapture();\n      \n        let item = this.timetracks.find(t => t.title === 'Contact Us Scene' && t.progress > 0.0 && t.progress < 1)\n        if (item) {\n          pAPIs.sky.group.rotation.y = item.progress * 3.141592 * 3\n          \n          pAPIs.foreGroundGroup.position.z = Math.min((item.progress * 3.0), 1) * 500\n        }\n        \n      });\n      \n      // let mat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });\n      // this.material = mat\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    // this.$on('addToParent', ({ parent }) => {\n    //   // console.log(this.node.title, 'addToParent', parent.node.title)\n    // })\n    this.$on('addChild', ({ child }) => {\n      // if (child.node.type === 'map') {\n      //   this.material.map = child.map\n      // }\n      // if (child.node.type === 'geometry') {\n      //   this.material.geometry = child.geometry\n      // }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    // this.$on('removeFromParent', ({ parent }) => {\n    //   // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    // })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "drawable",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false,
      "preventDelete": false
    }
  ],
  "timeline": {
    "totalTime": "30",
    "tracks": [
      {
        "_id": "_91814940643",
        "start": 0,
        "end": 8.488372093023205,
        "title": "Home Scene",
        "trashed": false
      },
      {
        "_id": "_54214377498",
        "start": 8.302325581395356,
        "end": 17.593023255813954,
        "title": "About Us Scene",
        "trashed": false
      },
      {
        "_id": "_63844190752",
        "start": 17.406976744186043,
        "end": 30.0813953488372,
        "title": "Contact Us Scene",
        "trashed": false
      },
      {
        "_id": "_42591864702",
        "start": 2.3175905639050143e-15,
        "end": 8.558139534883695,
        "title": "RotateView Camera",
        "trashed": false
      },
      {
        "_id": "_89730102779",
        "start": 8.232558139534902,
        "end": 30.116279069767376,
        "title": "Still Camera",
        "trashed": false
      }
    ]
  },
  "timeinfo": {
    "start": 0,
    "totalTime": "30",
    "timelinePlaying": true,
    "timelineControl": "timer",
    "timelinePercentageLast": 0,
    "timelinePercentage": 0,
    "loop": true,
    "elapsed": 0
  }
}