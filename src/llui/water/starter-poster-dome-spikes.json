{
  "nodes": [
    {
      "_id": "root",
      "title": "Your 3D App / Movie",
      "protected": true,
      "cannotDrop": true,
      "acceptDrop": [
        "pages"
      ],
      "isRoot": true,
      "type": "root",
      "to": null,
      "pos": {
        "x": 80,
        "y": 575
      },
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "src": "<template>\n  <div class=\"full\" ref=\"mounter\">\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    nodes: {},\n    \n    components: {},\n    timename: {},\n    timetracks: {}\n  },\n  data () {\n    return {\n      screen: false,\n      syncAll: {},\n      \n      composers: {},\n      cameras: {},\n      scenes: {},\n      \n      sceneID: '',\n      composerID: '',\n      cameraID: '',\n      \n      mouse: { x: 0, y: 0 },\n      renderer: false\n    }\n  },\n  watch: {\n    cameraID () {\n      window.dispatchEvent(new Event('resize'))\n      this.getSizeInfo()\n      this.syncAll()\n      this.syncScreen()\n    }\n  },\n  created () {\n    // this.$on('addToParent', ({ parent }) => {\n    //   // console.log(this.node.title, 'addToParent', parent)\n    // })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'camera') {\n        this.cameras[child.node._id] = child.camera\n        window.dispatchEvent(new Event('resize'))\n      }\n      if (child.node.type === 'scene') {\n        this.scenes[child.node._id] = child.scene\n      }\n      if (child.node.type === 'composer') {\n        this.composers[child.node._id] = child.composer\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    // this.$on('removeFromParent', ({ parent }) => {\n    //   console.log(this.node.title, 'removeFromParent', parent)\n    // })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestroy () {\n    this.stop()\n    this.$emit('remove', this)\n  },\n  mounted () {\n    // let sceneIDs = this.nodes.filter(t => t.type === 'scene').map(t => t._id)\n    // let cameraIDs = this.nodes.filter(t => t.type === 'camera').map(t => t._id)\n    // this.cameraID = cameraIDs[0]\n    // this.sceneID = sceneIDs[0]\n    this.init()\n  },\n  methods: {\n    init () {\n      this.setupRenderer()\n      this.getSizeInfo()\n      this.setupSizer()\n      this.syncSize()\n      this.start()\n      this.$emit('ready', this)\n    },\n    syncScreen () {\n      let camera = this.cameras[this.cameraID]\n      if (camera) {\n        let depth = 0\n        var aspect = camera.aspect\n        var dist = camera.position.z - (depth) // item\n        var vFOV = THREE.Math.degToRad(camera.fov) // convert vertical fov to radians\n        var screenHeight = 2 * Math.tan(vFOV / 2) * dist // visible height\n        var screenWidth = screenHeight * aspect // visible width\n        this.screen = {\n          aspect,\n          dist,\n          vFOV,\n          screenWidth,\n          screenHeight\n        }\n      }\n    },\n    setupRenderer () {\n      this.renderer = new THREE.WebGLRenderer({\n        antialias: true,\n        alpha: true,\n        preserveDrawingBuffer: true\n      })\n      this.renderer.domElement.style.marginBottom = '-6px'\n      this.$refs['mounter'].appendChild(this.renderer.domElement)\n    },\n    setupSizer () {\n      this.getSizeInfo()\n      window.addEventListener('resize', this.getSizeInfo, false)\n    },\n    getSizeInfo () {\n      if (!this.$refs['mounter']) {\n        return\n      }\n      var rect = this.$refs['mounter'].getBoundingClientRect()\n      this.rect = rect\n      this.size = {\n        width: rect.width,\n        height: rect.height,\n        aspect: rect.width / rect.height\n      }\n      this.sizeVec2 = new THREE.Vector2(rect.width, rect.height)\n      this.dpi = 2.0 // window.devicePixelRatio || 1.0\n    },\n    syncSize () {\n      let sync = () => {\n        let { composer, cameras, renderer, size, dpi, control } = this\n        let camera = cameras[this.cameraID]\n        if (control) {\n          control.update()\n        }\n        if (composer) {\n          composer.setSize(size.width * dpi, size.height * dpi)\n        }\n        \n        renderer.setPixelRatio(dpi)\n        renderer.setSize(size.width, size.height)\n        if (camera) {\n          camera.aspect = size.width / size.height\n          camera.updateProjectionMatrix()\n        }\n        this.syncScreen()\n      }\n      \n      sync()\n      this.syncAll = () => {\n        sync()\n      }\n      window.addEventListener('resize', sync, false)\n\n      this.$refs['mounter'].addEventListener('mousemove', (evt) => {\n        this.mouse.x = evt.pageX\n        this.mouse.y = evt.pageY\n      }, false)\n    },\n    stop () {\n      window.cancelAnimationFrame(this.rAFID)\n    },\n    start () {\n      let rAF = () => {\n        this.rAFID = window.requestAnimationFrame(rAF)\n        this.render()\n      }\n      this.rAFID = window.requestAnimationFrame(rAF)\n    },\n    resolveSwitchableArray () {\n      this.timetracks.filter(track => track.progress > 0.0001 && track.progress < 1).forEach((track) => {\n        let item = this.nodes.find(n => n.title === track.title)\n        \n        if (item && item._id) {\n          if (item.type === 'camera') {\n            this.cameraID = item._id\n          } else if (item.type === 'scene') {\n            this.sceneID = item._id\n          } else if (item.type === 'composer') {\n            this.composerID = item._id\n          }\n        }\n      })\n      \n      // disable composer when it's not here.\n      // this.timetracks.filter((track, i, arr) => track.progress >= 1 && i === arr.length - 1).forEach((track) => {\n      //   let item = this.nodes.find(n => n.title === track.title)\n      //   if (item && item._id) {\n      //     if (item.type === 'composer') {\n      //       this.composerID = ''\n      //     }\n      //   }\n      // })\n    },\n    // resolveSwitchable () {\n    // for (var kn in this.timename) {\n    //     if (this.timename[kn] > 0.001 && this.timename[kn] < 1) {\n    //       let item = this.nodes.find(n => n.title === kn)\n    //       if (item && item._id) {\n    //         if (item.type === 'camera') {\n    //           this.cameraID = item._id\n    //           // console.log('use cam ->', item.title)\n    //           // if (this.cameraID !== item._id) {\n    //           //   // window.dispatchEvent(new Event('resize'))\n    //           // }\n    //         } else if (item.type === 'scene') {\n    //           this.sceneID = item._id\n    //           // if (this.sceneID !== item._id) {\n    //           //   // console.log('use scene ->', item.title)\n    //           // }\n    //         }\n    //       }\n    //     }\n    //   }\n    // },\n    render () {\n      let { scenes, cameras, composers, renderer } = this\n      // this.resolveSwitchable()\n      this.resolveSwitchableArray()\n      \n      let scene = scenes[this.sceneID]\n      let camera = cameras[this.cameraID]\n      let composer = composers[this.composerID]\n\n      if (scene && camera && renderer && composer) {\n        composer.render()\n      } else if (scene && camera && renderer) {\n        renderer.render(scene, camera)\n      }\n    }\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "sceneID": "homepage",
      "cameraID": "_455500",
      "cannotDelete": false,
      "preventDelete": true,
      "confirmRecylce": false,
      "cannotChangeTitle": false
    },
    {
      "_id": "homepage",
      "title": "Home Scene",
      "protected": true,
      "type": "scene",
      "to": "_29338",
      "pos": {
        "x": 440,
        "y": 410
      },
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "library": [],
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      scene: false\n    }\n  },\n  methods: {\n    init () {\n      this.scene = new THREE.Scene()\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      this.components[this.node.to].$emit('addChild', { child })\n    \n      // add here\n      if (child.node.type === 'object3D') {\n        this.scene.add(child.object3D)\n      }\n      if (child.node.type === 'drawable') {\n        this.scene.add(child.drawable)\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "confirmRecylce": false,
      "showDeveloper": true
    },
    {
      "_id": "_317698",
      "title": "About Us Scene",
      "to": "_29338",
      "pos": {
        "x": 440,
        "y": 520
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      scene: false\n    }\n  },\n  methods: {\n    init () {\n      this.scene = new THREE.Scene()\n      this.scene.background = new THREE.Color(`#000000`)\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      this.components[this.node.to].$emit('addChild', { child })\n      \n      // add here\n      if (child.node.type === 'object3D') {\n        this.scene.add(child.object3D)\n      }\n      if (child.node.type === 'drawable') {\n        this.scene.add(child.drawable)\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "scene",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "confirmRecylce": false
    },
    {
      "_id": "_455500",
      "title": "RotateView Camera",
      "to": "_793268",
      "pos": {
        "x": 440,
        "y": 80
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {},\n    timename: {},\n    timetracks: {}\n  },\n  data () {\n    return {\n      camera: false\n    }\n  },\n  methods: {\n    init () {\n      let fov = 75\n      let rect = this.$parent.$el.getBoundingClientRect()\n      let aspect = rect.width / rect.height\n      let near = 0.1\n      let far = 100000000000000\n\n      this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far)\n      this.camera.position.z = 525\n      this.camera.lookAt(0,0,0)\n\n      this.$emit('exec', () => {\n        let item = this.timetracks.find(t => t.title === this.node.title && t.progress > 0.001 && t.progress < 1)\n        if (item) {\n          let x = 100 * Math.sin(3.14159265 * 2 * item.progress)\n          let y = 100 * Math.cos(3.14159265 * 2 * item.progress)\n          this.camera.lookAt(x, y, 0)\n        }\n      });\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "camera",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "confirmRecylce": false,
      "trashed": false
    },
    {
      "_id": "_793268",
      "title": "Cameras",
      "to": "root",
      "pos": {
        "x": 260,
        "y": 190
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      object3D: false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  methods: {\n    init () {\n      this.object3D = new THREE.Object3D()\n    }\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      this.components[this.node.to].$emit('addChild', { child })\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "organiser.camera",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "preventDelete": true,
      "confirmRecylce": false,
      "hideRecycle": true,
      "cannotChangeTitle": true
    },
    {
      "_id": "_29338",
      "title": "Scenes",
      "to": "root",
      "pos": {
        "x": 260,
        "y": 575
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      object3D: false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  methods: {\n    init () {\n      this.object3D = new THREE.Object3D()\n    }\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      this.components[this.node.to].$emit('addChild', { child })\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "organiser.scene",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "preventDelete": true,
      "confirmRecylce": false,
      "hideRecycle": true,
      "cannotChangeTitle": true
    },
    {
      "_id": "_247335",
      "title": "Still Camera",
      "to": "_793268",
      "pos": {
        "x": 440,
        "y": 190
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {},\n    timename: {},\n    timetracks: {}\n  },\n  data () {\n    return {\n      camera: false\n    }\n  },\n  methods: {\n    init () {\n      let fov = 75\n      let rect = this.$parent.$el.getBoundingClientRect()\n      let aspect = rect.width / rect.height\n      let near = 0.1\n      let far = 100000000000000\n\n      this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far)\n      this.camera.position.z = 500\n      this.camera.lookAt(0,0,0)\n      \n      // this.$emit('exec', () => {\n      //   // use time track\n      //   let item = this.timetracks.find(t => t.title === this.node.title && t.progress > 0.001 && t.progress < 1)\n      //   if (item) {\n      //     this.camera.position.z = -50 + (item.progress) * 1000\n      //   }\n      // });\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "camera",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_871971",
      "title": "Contact Us Scene",
      "to": "_29338",
      "pos": {
        "x": 440,
        "y": 630
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      scene: false\n    }\n  },\n  methods: {\n    init () {\n      this.scene = new THREE.Scene()\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      this.components[this.node.to].$emit('addChild', { child })\n      \n      // add here\n      if (child.node.type === 'object3D') {\n        this.scene.add(child.object3D)\n      }\n      if (child.node.type === 'drawable') {\n        this.scene.add(child.drawable)\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "scene",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "trashed": false,
      "confirmRecylce": false
    },
    {
      "_id": "_208728",
      "title": "Poster",
      "to": "_871971",
      "pos": {
        "x": 620,
        "y": 630
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      geo: false,\n      mat: false,\n      drawable: false\n    }\n  },\n  methods: {\n    init () {\n      // let geo = new THREE.BoxBufferGeometry(100, 100, 100, 20, 20);\n      // let mat = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.1 });\n      let map = new THREE.TextureLoader().load(`https://res.cloudinary.com/hslkngave/image/upload/v1559309484/a8uctpsnyjsdnampbmva.png`)\n      this.drawable = new THREE.Mesh()\n      this.drawable.geometry = new THREE.PlaneBufferGeometry(500, 500, 2, 2);\n      this.drawable.material = new THREE.MeshBasicMaterial({ color: new THREE.Color(0xffffff),  map })\n      this.drawable.visible = true\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'material') {\n        this.drawable.material = child.material\n        this.material = child.material\n      }\n      if (child.node.type === 'geometry') {\n        this.drawable.geometry = child.geometry\n        this.geometry = child.geometry\n      }\n      if (this.geometry && this.material) {\n        this.drawable.visible = true\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "drawable",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false,
      "preventDelete": false
    },
    {
      "_id": "_967525",
      "title": "Golen Spikes",
      "to": "_317698",
      "pos": {
        "x": 620,
        "y": 520
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      geo: false,\n      mat: false,\n      drawable: false\n    }\n  },\n  methods: {\n    init () {\n      \n      let makeAPI = ({ renderer }) => {\n        var api = {}\n      \n        function prepIndexer (texture, SIZE) {\n          var pixels = texture.image.data\n          var p = 0\n          let max = SIZE * SIZE\n          for (var j = 0; j < max; j++) {\n            pixels[p + 0] = j\n            pixels[p + 1] = j / (max)\n            pixels[p + 2] = SIZE\n            pixels[p + 3] = 1.0\n            p += 4\n          }\n        }\n      \n        var ticker = 0\n        let SIZE = 192\n        \n        var gpuCompute = new GPUComputationRenderer(SIZE, SIZE, renderer)\n      \n        var indexerTexture = gpuCompute.createTexture()\n        prepIndexer(indexerTexture, SIZE)\n      \n        var pingTarget = gpuCompute.createRenderTarget()\n        var pongTarget = gpuCompute.createRenderTarget()\n      \n        let pingMat, pongMat;\n      \n        let displayV = `uniform sampler2D posTex;\n        uniform float pointSize;\n        uniform sampler2D indexerTexture;\n        uniform sampler2D audio;\n      \n        varying vec2 vUv;\n        uniform float time;\n        \n      \n        void main() {\n            vec4 info = texture2D(indexerTexture, uv);\n      \n            vec4 pos = texture2D(posTex, uv);\n            \n            vec4 audioT = texture2D(audio, uv);\n      \n            vec4 mvPosition = modelViewMatrix * vec4(pos.xyz + normalize(pos.xyz) * 3.0 * audioT.xyz * 1.0, 1.0);\n            vec4 outputPos = projectionMatrix * mvPosition;\n      \n            // outputPos.y = outputPos.y + sin(outputPos.y + time * 50.0) * sin(outputPos.y + time * 50.0);\n            // outputPos.x = outputPos.x + cos(outputPos.x + time * 50.0) * sin(outputPos.x + time * 50.0);\n      \n            vUv = uv;\n      \n            gl_Position = outputPos;\n            gl_PointSize = 1.0;\n        }\n        `\n      \n        let displayF = `\n        // uniform sampler2D posTex;\n      \n        uniform sampler2D picture;\n        uniform float opacity;\n      \n        uniform float time;\n          \n        uniform vec3 mainColor; \n          \n        varying vec2 vUv;\n      \n        void main() {\n            \n            vec2 screen = vec2(gl_FragCoord.x, gl_FragCoord.y) / resolution.xy;\n            \n            screen.y *= 16.0 / 9.0;\n            screen.y -= 16.0 / 9.0 * 0.75;\n            \n            screen.x -= 0.5;\n            \n            \n            // vec4 imgColor = texture2D(picture, (screen));\n            \n            gl_FragColor = vec4(mainColor, 1.0);\n        }\n        `\n        var defaultPingPong = `//\n        //THANK YOU for your support <3 \n        //\n        \n        #include <common>\n        precision highp sampler2D;\n        \n        //\n        //  Classic Perlin 3D Noise\n        //  by Stefan Gustavson\n        //\n        \n        vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n        vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n        \n        float cnoise(vec2 P){\n          vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n          vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n          Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n          vec4 ix = Pi.xzxz;\n          vec4 iy = Pi.yyww;\n          vec4 fx = Pf.xzxz;\n          vec4 fy = Pf.yyww;\n          vec4 i = permute(permute(ix) + iy);\n          vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n          vec4 gy = abs(gx) - 0.5;\n          vec4 tx = floor(gx + 0.5);\n          gx = gx - tx;\n          vec2 g00 = vec2(gx.x,gy.x);\n          vec2 g10 = vec2(gx.y,gy.y);\n          vec2 g01 = vec2(gx.z,gy.z);\n          vec2 g11 = vec2(gx.w,gy.w);\n          vec4 norm = 1.79284291400159 - 0.85373472095314 *\n              vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n          g00 *= norm.x;\n          g01 *= norm.y;\n          g10 *= norm.z;\n          g11 *= norm.w;\n          float n00 = dot(g00, vec2(fx.x, fy.x));\n          float n10 = dot(g10, vec2(fx.y, fy.y));\n          float n01 = dot(g01, vec2(fx.z, fy.z));\n          float n11 = dot(g11, vec2(fx.w, fy.w));\n          vec2 fade_xy = fade(Pf.xy);\n          vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n          float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n          return 2.3 * n_xy;\n        }\n        \n        #define M_PI 3.1415926535897932384626433832795\n        float atan2(in float y, in float x) {\n          bool xgty = (abs(x) > abs(y));\n          return mix(M_PI/2.0 - atan(x,y), atan(y,x), float(xgty));\n        }\n        \n        vec3 ballify (vec3 pos, float r) {\n          float az = atan2(pos.y, pos.x);\n          float el = atan2(pos.z, sqrt(pos.x * pos.x + pos.y * pos.y));\n          return vec3(\n            r * cos(el) * cos(az),\n            r * cos(el) * sin(az),\n            r * sin(el)\n          );\n        }\n        \n        vec3 fromBall(float r, float az, float el) {\n          return vec3(\n            r * cos(el) * cos(az),\n            r * cos(el) * sin(az),\n            r * sin(el)\n          );\n        }\n        \n        void toBall(vec3 pos, out float az, out float el) {\n          az = atan2(pos.y, pos.x);\n          el = atan2(pos.z, sqrt(pos.x * pos.x + pos.y * pos.y));\n        }\n        \n        mat3 rotateZ(float rad) {\n            float c = cos(rad);\n            float s = sin(rad);\n            return mat3(\n                c, s, 0.0,\n                -s, c, 0.0,\n                0.0, 0.0, 1.0\n            );\n        }\n        \n        mat3 rotateY(float rad) {\n            float c = cos(rad);\n            float s = sin(rad);\n            return mat3(\n                c, 0.0, -s,\n                0.0, 1.0, 0.0,\n                s, 0.0, c\n            );\n        }\n        \n        mat3 rotateX(float rad) {\n            float c = cos(rad);\n            float s = sin(rad);\n            return mat3(\n                1.0, 0.0, 0.0,\n                0.0, c, s,\n                0.0, -s, c\n            );\n        }\n        \n        // float Gravity(float z) {\n        //   float G, eZ;\n        //   const float ER = 6378150.0;\n        //   const float ER2 = 6378150.0 * 6378150.0;\n        //   eZ = ER + z;\n        //   G = 9.81 * ER2 / (eZ * eZ);\n        //   return G;\n        // }\n        \n        float constrain(float val, float min, float max) {\n            if (val < min) {\n                return min;\n            } else if (val > max) {\n                return max;\n            } else {\n                return val;\n            }\n        }\n        \n        vec3 getDiff (vec3 lastPos, vec3 mouse) {\n          vec3 diff = lastPos.xyz - mouse;\n          float distance = constrain(length(diff), 1.0, 5.0);\n          float strength = 1.0 / (distance * distance);\n        \n          diff = normalize(diff);\n          diff = diff * strength * -1.0;\n        \n          return diff;\n        }\n        \n        vec3 resDiff (in vec3 lastPos, in vec3 mouse) {\n          vec3 diff = lastPos - mouse;\n          diff = normalize(diff) * -1.0;\n          return diff;\n        }\n        \n        uniform float time;\n        uniform sampler2D lastTexture;\n        uniform sampler2D indexerTexture;\n        \n        uniform vec3 mouse;\n        \n        void main () {\n        \n          // @v@\n          // @.@\n        \n          vec2 uv = gl_FragCoord.xy / resolution.xy;\n        \n          vec4 indexer = texture2D(indexerTexture, uv);\n          vec4 lastPos = texture2D(lastTexture, uv);\n        \n          float i = indexer.x;\n          float e = indexer.y;\n          float u = indexer.z;\n        \n          vec3 nextPos = vec3(lastPos);\n        \n          float x = 0.5 - rand(uv + .1);\n          float y = 0.5 - rand(uv + .2);\n          float z = 0.5 - rand(uv + .3);\n          \n          vec3 randomBall = ballify(vec3(x, y, z) + mouse, 1.0);\n          \n          vec3 pt1 = ballify(randomBall + nextPos, 15.0);\n          pt1.z += cnoise(pt1.xy + time * 20.0) * 6.0;\n          \n          \n          vec3 pt2 = ballify(randomBall + nextPos, 15.0);\n          pt2.z += rand(pt2.xy + time * 20.0);\n          \n          \n          nextPos = mix(pt1, pt2, smoothstep(0.0, 1.0, abs(distance(mouse, vec3(0.0))) / 0.5));\n          nextPos += getDiff(nextPos, mouse * 17.0) * 50.0;\n          \n          // remix code end here//\n          gl_FragColor = vec4(nextPos, 1.0);\n        }\n\n      \n        `\n      \n      \n      \n        let mouseV3 = new THREE.Vector3(0.0, 0.0, 0.0);\n      \n        let init = ({ pingPongShader }) => {\n          try {\n            let newPingMat = gpuCompute.createShaderMaterial(pingPongShader, {\n              lastTexture: { value: null },\n              indexerTexture: { value: indexerTexture },\n              time: { value: 0 },\n              mouse: { value: mouseV3 }\n            })\n            let newPongMat = gpuCompute.createShaderMaterial(pingPongShader, {\n              lastTexture: { value: null },\n              indexerTexture: { value: indexerTexture },\n              time: { value: 0 },\n              mouse: { value: mouseV3 }\n            })   \n            pingMat = newPingMat\n            pongMat = newPongMat\n          } catch (e) {\n            console.error(e)    \n          }\n        }\n      \n        init({ pingPongShader: defaultPingPong })\n      \n      \n        // sim part\n        let procSim = () => {\n          pingMat.uniforms.lastTexture.value = pongTarget.texture\n          pongMat.uniforms.lastTexture.value = pingTarget.texture\n      \n          pingMat.uniforms.time.value = window.performance.now() * 0.0001\n          pongMat.uniforms.time.value = window.performance.now() * 0.0001\n        }\n        \n        let rect = renderer.domElement.getBoundingClientRect()\n        \n        // display part\n        var geometry = new THREE.PlaneBufferGeometry(1.0, 1.0, SIZE - 1, SIZE - 1)\n        var material = new THREE.ShaderMaterial({\n          // blending: THREE.AdditiveBlending,\n          // depthTest: false,\n          transparent: true,\n          depthWrite: false,\n          vertexShader: displayV,\n          fragmentShader: displayF,\n          defines: {\n            aspectRatio: `${Number(rect.width / rect.height).toFixed(1)}`,\n            resolution: 'vec2( ' + rect.width.toFixed(1) + ', ' + rect.height.toFixed(1) + ' )'\n          },\n          uniforms: {\n            mainColor: { value: new THREE.Color('#ff0000') },\n            time: { value: 0 },\n            opacity: { value: 0.5 },\n            posTex: { value: null },\n\n            indexerTexture: { value: indexerTexture },\n      \n            picture: { value: null },\n            audio: { value: null },\n            pointSize: { value: window.devicePixelRatio || 1.0 }\n          }\n        })\n      \n        var points = new THREE.Points(geometry, material)\n        // var points = ev.points = new THREE.Points(geometry, material)\n        points.matrixAutoUpdate = false\n        points.updateMatrix()\n        points.frustumCulled = false\n      \n        \n        api.compute = () => {\n          procSim();\n          \n          if (ticker % 2 === 0) {\n            gpuCompute.doRenderTarget(pongMat, pongTarget)\n          } else {\n            gpuCompute.doRenderTarget(pingMat, pingTarget)\n          }\n      \n          if (ticker % 2 === 0) {\n            material.uniforms.posTex.value = pongTarget.texture;\n          } else {\n            material.uniforms.posTex.value = pingTarget.texture;\n          }\n          ticker++\n          \n          if (api.video) {\n            material.uniforms.picture.value = api.video\n          }\n          \n          material.uniforms.time.value = window.performance.now() * 0.0001\n        }\n        api.uniforms = material.uniforms\n        api.renderable = points;\n        api.mouse = mouseV3;\n      \n        return api\n      }\n      \n      let waitUntil = ({ getter }) => {\n        return new Promise((resolve) => {\n          let tt = setInterval(() => {\n            let val = getter()\n            if (val) {\n              clearInterval(tt)\n              resolve(val)\n            }\n          }, 10)\n        });\n      };\n      \n      waitUntil({\n        getter: () => {\n          let node = this.nodes.find(n => n.type === 'root') \n          if (node && this.components[node._id] && this.components[node._id].renderer) {\n            return this.components[node._id].renderer\n          }\n        }\n      }).then((renderer) => {\n        let simAPI = makeAPI({ renderer });\n        let o3 = new THREE.Object3D();\n        this.drawable = o3;\n        o3.scale.x = 20.0\n        o3.scale.y = 20.0\n        o3.scale.z = 20.0\n        simAPI.uniforms.mainColor.value = new THREE.Color('#ffc100');\n        o3.add(simAPI.renderable);\n        \n        this.$emit('exec', () => {\n          simAPI.compute()\n        });\n        this.$emit('ready', this)\n      });\n      \n      // let geo = new THREE.BoxBufferGeometry(100, 100, 100, 20, 20);\n      // let mat = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.1 });\n      // this.drawable = new THREE.Mesh()\n    }\n  },\n  mounted () {\n    this.init()\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'material') {\n        this.drawable.material = child.material\n        this.material = child.material\n      }\n      if (child.node.type === 'geometry') {\n        this.drawable.geometry = child.geometry\n        this.geometry = child.geometry\n      }\n      if (this.geometry && this.material) {\n        this.drawable.visible = true\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [
        {
          "_id": "_791665",
          "url": "https://igraph.effectnode.com/threejs/examples/js/GPUComputationRenderer.js"
        }
      ],
      "type": "drawable",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "confirmRecylce": false,
      "preventDelete": false,
      "showDeveloper": false
    },
    {
      "_id": "_692",
      "title": "Dome",
      "to": "homepage",
      "trashed": false,
      "pos": {
        "x": 620,
        "y": 410
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {},\n    timetracks: {},\n    timename: {},\n    tmeinfo: {}\n  },\n  data () {\n    return {\n    }\n  },\n  methods: {\n    init () {\n      let EventDispatcher = THREE.EventDispatcher\n            \n      class Plane {\n        constructor ({ link, at }) {\n          let size = 500\n          this.geo = new THREE.PlaneBufferGeometry(size, size, 64, 64)\n          let texture = new THREE.TextureLoader().load(link)\n          this.material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, map: texture, side: THREE.BackSide })\n          this.mesh = new THREE.Mesh(this.geo, this.material)\n      \n          this.group = new THREE.Object3D()\n          this.group.add(this.mesh)\n          if (at === 'px') {\n            this.group.position.x = size * 0.5 * 1.0\n            this.group.rotation.y = Math.PI * 0.5 * 1.0\n          } else if (at === 'nx') {\n            this.group.position.x = size * 0.5 * -1.0\n            this.group.rotation.y = Math.PI * 0.5 * -1.0\n          } else if (at === 'py') {\n            this.group.position.y = size * 0.5 * 1.0\n            this.group.rotation.x = Math.PI * 0.5 * -1.0\n          } else if (at === 'ny') {\n            this.group.position.y = size * 0.5 * -1.0\n            this.group.rotation.x = Math.PI * 0.5 * 1.0\n          } if (at === 'pz') {\n            this.group.position.z = size * 0.5 * 1.0\n            this.group.rotation.y = Math.PI * 0.5 * 4.0\n          } else if (at === 'nz') {\n            this.group.position.z = size * 0.5 * -1.0\n            this.group.rotation.y = Math.PI * 0.5 * -2.0\n          }\n        }\n      }\n      \n      class Sky {\n        constructor ({ links }) {\n          let group = new THREE.Object3D()\n          this.group = group\n      \n          this.fliper = new THREE.Object3D()\n          this.fliper.rotation.z = Math.PI\n          this.fliper.rotation.y = Math.PI\n          this.group.add(this.fliper)\n      \n          var at = [\n            'px',\n            'nx',\n      \n            'py',\n            'ny',\n      \n            'pz',\n            'nz'\n          ]\n      \n          this.planes = links.map((link, i) => {\n            let plane = new Plane({\n              link,\n              at: at[i]\n            })\n            return plane\n          })\n      \n          this.planes.forEach((plane) => {\n            this.fliper.add(plane.group)\n            return plane\n          })\n        }\n      }\n      \n      class Sphere {\n        constructor ({ envMap }) {\n          // // Create car\n          var geo = new THREE.SphereBufferGeometry(100, 100, 64, 64)\n          var material = new THREE.MeshBasicMaterial({ color: 0xffffff, envMap, side: THREE.BackSide })\n          var mesh = new THREE.Mesh(geo, material)\n          this.mesh = mesh\n          this.group = new THREE.Object3D()\n          this.group.add(mesh)\n        }\n      }\n      \n      class Universe extends EventDispatcher {\n        constructor ({ renderer, scene, links, resolution = 512 }) {\n          super()\n          this.renderer = renderer\n          this.scene = new THREE.Scene()\n      \n          this.group = new THREE.Object3D()\n      \n          // background skybox\n          this.backGroundGroup = new THREE.Object3D()\n          this.group.add(this.backGroundGroup)\n      \n          // visible object\n          this.foreGroundGroup = new THREE.Object3D()\n          this.group.add(this.foreGroundGroup)\n          \n      \n          this.sky = new Sky({\n            links\n          })\n          this.backGroundGroup.add(this.sky.group)\n\n\n      \n          this.cubecam = new THREE.CubeCamera(1, 3000, resolution)\n          this.group.add(this.cubecam)\n      \n          this.sphere = new Sphere({\n            envMap: this.cubecam.renderTarget.texture\n          })\n      \n          this.foreGroundGroup.add(this.sphere.group)\n      \n          this.animate = () => {\n      \n          }\n          this.scene.add(this.group)\n          \n          this.preCapture = () => {\n            this.backGroundGroup.visible = true\n            this.foreGroundGroup.visible = false\n          }\n          this.capture = () => {\n            this.animate()\n            this.cubecam.update(this.renderer, this.scene)\n          }\n          this.postCapture = () => {\n            this.backGroundGroup.visible = false\n            this.foreGroundGroup.visible = true\n          }\n        }\n      }\n      \n      let rootnode = this.nodes.find(no => no.type === 'root')\n      let rootCompo = this.components[rootnode._id]\n      \n      let pAPIs = new Universe({\n        renderer: rootCompo.renderer,\n        // scene: this.engine.scene,\n        links: [\n          `https://res.cloudinary.com/htdjnmcsz/image/upload/v1557820567/zngndtrninocunhymquz.png`,\n          `https://res.cloudinary.com/htdjnmcsz/image/upload/v1557820567/kpyurwejhva9yd65fsjk.png`,\n          `https://res.cloudinary.com/htdjnmcsz/image/upload/v1557820567/qrdjxy3xe5bxbuotsshz.png`,\n          `https://res.cloudinary.com/htdjnmcsz/image/upload/v1557820567/resdrnerd9n3fhjuxltv.png`,\n          `https://res.cloudinary.com/htdjnmcsz/image/upload/v1557820567/ta8ggppgiyiuwykkmnjc.png`,\n          `https://res.cloudinary.com/htdjnmcsz/image/upload/v1557820567/epuaxw3fkdvftl5pmfwv.png`\n          \n          // this.textures.px,\n          // this.textures.nx,\n          // this.textures.py,\n          // this.textures.ny,\n          // this.textures.pz,\n          // this.textures.nz          \n          \n          // require('../Universe/img/mplus-cubemap/v1/px.jpg'),\n          // require('../Universe/img/mplus-cubemap/v1/nx.jpg'),\n\n          // require('../Universe/img/mplus-cubemap/v1/py.jpg'),\n          // require('../Universe/img/mplus-cubemap/v1/ny.jpg'),\n\n          // require('../Universe/img/mplus-cubemap/v1/pz.jpg'),\n          // require('../Universe/img/mplus-cubemap/v1/nz.jpg')\n\n          // require('../Universe/img/home/px.jpg'),\n          // require('../Universe/img/home/nx.jpg'),\n\n          // require('../Universe/img/home/py.jpg'),\n          // require('../Universe/img/home/ny.jpg'),\n\n          // require('../Universe/img/home/pz.jpg'),\n          // require('../Universe/img/home/nz.jpg')\n        ],\n        resolution: 1024\n      });\n      \n      this.drawable = pAPIs.foreGroundGroup\n      \n      let findScene = (node) => {\n        return new Promise((resolve) => {\n          let tt = setInterval(() => {\n            let parentCompo = this.components[node.to]\n            if (parentCompo) {\n              clearInterval(tt);\n              let parentNode =  this.nodes.find(n => n._id === node.to)\n              resolve({ parentNode, parentCompo })\n            }\n          }, 3)\n        })\n      }\n      \n      let findParentTillScene = async ({ node, cb }) => {\n        let res = await findScene(node)\n        if (res.parentNode.type === 'scene') {\n          cb(res)\n        } else {\n          findParentTillScene({ node: res.parentNode, cb })\n        }\n      }\n      \n      let findSceneTitle = () => {\n        return new Promise((resolve) => {\n          findParentTillScene({ \n            node: this.node, \n            cb: ({ parentNode, parentCompo }) => {\n              let theSceneOfThisNode = parentNode.title\n              resolve(theSceneOfThisNode)\n            } \n          })\n        })\n      }\n      \n      findSceneTitle()\n        .then((theSceneOfThisNode) => {\n          this.$emit('exec', () => {\n            pAPIs.preCapture();\n            pAPIs.capture();\n            pAPIs.postCapture();\n          \n            let item = this.timetracks.find(t => t.title === theSceneOfThisNode && t.progress > 0.0 && t.progress < 1)\n            if (item) {\n              pAPIs.sky.group.rotation.y = item.progress * 3.141592 * 3\n              \n              pAPIs.foreGroundGroup.position.z = Math.min((item.progress * 3.0), 1) * 500\n            }\n            \n          });\n        })\n      \n      // let mat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });\n      // this.material = mat\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    // this.$on('addToParent', ({ parent }) => {\n    //   // console.log(this.node.title, 'addToParent', parent.node.title)\n    // })\n    this.$on('addChild', ({ child }) => {\n      // if (child.node.type === 'map') {\n      //   this.material.map = child.map\n      // }\n      // if (child.node.type === 'geometry') {\n      //   this.material.geometry = child.geometry\n      // }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    // this.$on('removeFromParent', ({ parent }) => {\n    //   // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    // })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "drawable",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false,
      "preventDelete": false
    },
    {
      "_id": "_425201",
      "title": "EarthShake Camera",
      "to": "_793268",
      "pos": {
        "x": 440,
        "y": 300
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\n// camera shake is from http://brianchirls.github.io/Seriously.js/transforms/seriously.camerashake.js\n\n    /*\nmat4 matrix functions borrowed from gl-matrix by toji\nhttps://github.com/toji/gl-matrix\nLicense: https://github.com/toji/gl-matrix/blob/master/LICENSE.md\n*/\nvar mat4 = {\n    /*\n * mat4.frustum\n * Generates a frustum matrix with the given bounds\n *\n * Params:\n * left, right - scalar, left and right bounds of the frustum\n * bottom, top - scalar, bottom and top bounds of the frustum\n * near, far - scalar, near and far bounds of the frustum\n * dest - Optional, mat4 frustum matrix will be written into\n *\n * Returns:\n * dest if specified, a new mat4 otherwise\n */\n    frustum: function(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = mat4.create();\n        }\n        var rl = (right - left)\n          , tb = (top - bottom)\n          , fn = (far - near);\n        dest[0] = (near * 2) / rl;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 0;\n        dest[4] = 0;\n        dest[5] = (near * 2) / tb;\n        dest[6] = 0;\n        dest[7] = 0;\n        dest[8] = (right + left) / rl;\n        dest[9] = (top + bottom) / tb;\n        dest[10] = -(far + near) / fn;\n        dest[11] = -1;\n        dest[12] = 0;\n        dest[13] = 0;\n        dest[14] = -(far * near * 2) / fn;\n        dest[15] = 0;\n        return dest;\n    },\n\n    perspective: function(fovy, aspect, near, far, dest) {\n        var top = near * Math.tan(fovy * Math.PI / 360.0)\n          , right = top * aspect;\n        return mat4.frustum(-right, right, -top, top, near, far, dest);\n    },\n    multiply: function(dest, mat, mat2) {\n        // Cache the matrix values (makes for huge speed increases!)\n        var a00 = mat[0]\n          , a01 = mat[1]\n          , a02 = mat[2]\n          , a03 = mat[3]\n          , a10 = mat[4]\n          , a11 = mat[5]\n          , a12 = mat[6]\n          , a13 = mat[7]\n          , a20 = mat[8]\n          , a21 = mat[9]\n          , a22 = mat[10]\n          , a23 = mat[11]\n          , a30 = mat[12]\n          , a31 = mat[13]\n          , a32 = mat[14]\n          , a33 = mat[15]\n          , // Cache only the current line of the second matrix\n        b0 = mat2[0]\n          , b1 = mat2[1]\n          , b2 = mat2[2]\n          , b3 = mat2[3];\n        dest[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        dest[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        dest[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        dest[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = mat2[4];\n        b1 = mat2[5];\n        b2 = mat2[6];\n        b3 = mat2[7];\n        dest[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        dest[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        dest[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        dest[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = mat2[8];\n        b1 = mat2[9];\n        b2 = mat2[10];\n        b3 = mat2[11];\n        dest[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        dest[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        dest[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        dest[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = mat2[12];\n        b1 = mat2[13];\n        b2 = mat2[14];\n        b3 = mat2[15];\n        dest[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        dest[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        dest[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        dest[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        return dest;\n    },\n    identity: function(dest) {\n        dest[0] = 1;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 0;\n        dest[4] = 0;\n        dest[5] = 1;\n        dest[6] = 0;\n        dest[7] = 0;\n        dest[8] = 0;\n        dest[9] = 0;\n        dest[10] = 1;\n        dest[11] = 0;\n        dest[12] = 0;\n        dest[13] = 0;\n        dest[14] = 0;\n        dest[15] = 1;\n        return dest;\n    },\n    copy: function(out, a) {\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        out[3] = a[3];\n        out[4] = a[4];\n        out[5] = a[5];\n        out[6] = a[6];\n        out[7] = a[7];\n        out[8] = a[8];\n        out[9] = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n        return out;\n    }\n}\n\n\n/**\n* Returns the translation vector component of a transformation\n*  matrix. If a matrix is built with fromRotationTranslation,\n*  the returned vector will be the same as the translation vector\n*  originally supplied.\n* @param  {vec3} out Vector to receive translation component\n* @param  {mat4} mat Matrix to be decomposed (input)\n* @return {vec3} out\n*/\nfunction getTranslation(out, mat) {\n    out[0] = mat[12];\n    out[1] = mat[13];\n    out[2] = mat[14];\n    return out;\n}\n/**\n* Returns the scaling factor component of a transformation\n*  matrix. If a matrix is built with fromRotationTranslationScale\n*  with a normalized Quaternion paramter, the returned vector will be\n*  the same as the scaling vector\n*  originally supplied.\n* @param  {vec3} out Vector to receive scaling factor component\n* @param  {mat4} mat Matrix to be decomposed (input)\n* @return {vec3} out\n*/\nfunction getScaling(out, mat) {\n    let m11 = mat[0];\n    let m12 = mat[1];\n    let m13 = mat[2];\n    let m21 = mat[4];\n    let m22 = mat[5];\n    let m23 = mat[6];\n    let m31 = mat[8];\n    let m32 = mat[9];\n    let m33 = mat[10];\n    out[0] = Math.hypot(m11, m12, m13);\n    out[1] = Math.hypot(m21, m22, m23);\n    out[2] = Math.hypot(m31, m32, m33);\n    return out;\n}\n/**\n* Returns a quaternion representing the rotational component\n*  of a transformation matrix. If a matrix is built with\n*  fromRotationTranslation, the returned quaternion will be the\n*  same as the quaternion originally supplied.\n* @param {quat} out Quaternion to receive the rotation component\n* @param {mat4} mat Matrix to be decomposed (input)\n* @return {quat} out\n*/\nfunction getRotation(out, mat) {\n    let scaling = [1, 1, 1];\n    getScaling(scaling, mat);\n    let is1 = 1 / scaling[0];\n    let is2 = 1 / scaling[1];\n    let is3 = 1 / scaling[2];\n    let sm11 = mat[0] * is1;\n    let sm12 = mat[1] * is2;\n    let sm13 = mat[2] * is3;\n    let sm21 = mat[4] * is1;\n    let sm22 = mat[5] * is2;\n    let sm23 = mat[6] * is3;\n    let sm31 = mat[8] * is1;\n    let sm32 = mat[9] * is2;\n    let sm33 = mat[10] * is3;\n    let trace = sm11 + sm22 + sm33;\n    let S = 0;\n    if (trace > 0) {\n        S = Math.sqrt(trace + 1.0) * 2;\n        out[3] = 0.25 * S;\n        out[0] = (sm23 - sm32) / S;\n        out[1] = (sm31 - sm13) / S;\n        out[2] = (sm12 - sm21) / S;\n    } else if ((sm11 > sm22) && (sm11 > sm33)) {\n        S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n        out[3] = (sm23 - sm32) / S;\n        out[0] = 0.25 * S;\n        out[1] = (sm12 + sm21) / S;\n        out[2] = (sm31 + sm13) / S;\n    } else if (sm22 > sm33) {\n        S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n        out[3] = (sm31 - sm13) / S;\n        out[0] = (sm12 + sm21) / S;\n        out[1] = 0.25 * S;\n        out[2] = (sm23 + sm32) / S;\n    } else {\n        S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n        out[3] = (sm12 - sm21) / S;\n        out[0] = (sm31 + sm13) / S;\n        out[1] = (sm23 + sm32) / S;\n        out[2] = 0.25 * S;\n    }\n    return out;\n}\n\n\n\n/*\nCamera Shake\n- amplitude (x/y)\n- rotation (degrees)\n- frequency\n- octaves\n- autoScale (true/false)\n*/\n\n/*\nSimplex Noise\nadapted from https://github.com/jwagner/simplex-noise.js\n*/\n\nvar PI = Math.PI, f2 = 0.5 * (Math.sqrt(3.0) - 1.0), g2 = (3.0 - Math.sqrt(3.0)) / 6.0, random = Math.random, p, perm, permMod12, grad3, initialized = false;\n\nfunction initializeSimplex() {\n    //initialize simplex lookup tables\n    var i;\n    if (!initialized) {\n        p = new Uint8Array(256);\n        perm = new Uint8Array(512);\n        permMod12 = new Uint8Array(512);\n        grad3 = new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]);\n\n        for (i = 0; i < 256; i++) {\n            p[i] = random() * 256;\n        }\n        for (i = 0; i < 512; i++) {\n            perm[i] = p[i & 255];\n            permMod12[i] = perm[i] % 12;\n        }\n        initialized = true;\n    }\n}\n\nfunction noise2D(xin, yin) {\n    var n0 = 0, // Noise contributions from the three corners\n    n1 = 0, // Skew the input space to determine which simplex cell we're in\n    n2 = 0, s = (xin + yin) * f2, // Hairy factor for 2D\n    i = Math.floor(xin + s), j = Math.floor(yin + s), t = (i + j) * g2, xx0 = i - t, // Unskew the cell origin back to (x,y) space\n    yy0 = j - t, x0 = xin - xx0, y0 = yin - yy0, /*\n    For the 2D case, the simplex shape is an equilateral triangle.\n    Determine which simplex we are in.\n\n    Offsets for second (middle) corner of simplex in (i,j) coords\n    */\n    i1 = x0 > y0 ? 1 : 0, j1 = (i1 + 1) % 2, //opposite of i1\n\n    x1 = x0 - i1 + g2, y1 = y0 - j1 + g2, x2 = x0 - 1 + 2 * g2, y2 = y0 - 1 + 2 * g2, ii = i & 255, jj = j & 255, t0 = 0.5 - x0 * x0 - y0 * y0, t1, t2, gi;\n\n    if (t0 >= 0) {\n        gi = permMod12[ii + perm[jj]] * 3;\n        t0 *= t0;\n        n0 = t0 * t0 * (grad3[gi] * x0 + grad3[gi + 1] * y0);\n        // (x,y) of grad3 used for 2D gradient\n    }\n\n    t1 = 0.5 - x1 * x1 - y1 * y1;\n    if (t1 >= 0) {\n        gi = permMod12[ii + i1 + perm[jj + j1]] * 3;\n        t1 *= t1;\n        n1 = t1 * t1 * (grad3[gi] * x1 + grad3[gi + 1] * y1);\n    }\n\n    t2 = 0.5 - x2 * x2 - y2 * y2;\n    if (t2 >= 0) {\n        gi = permMod12[ii + 1 + perm[jj + 1]] * 3;\n        t2 *= t2;\n        n2 = t2 * t2 * (grad3[gi] * x2 + grad3[gi + 1] * y2);\n    }\n\n    return 70.0 * (n0 + n1 + n2);\n}\n\nfunction makeAwesomeShakyItem() {\n    var me = {\n        width: 100,\n        height: 100,\n        transformed: false,\n        matrix: mat4.identity([])\n    }\n      , octaves = 1\n      , time = 0\n      , amplitudeX = 0\n      , amplitudeY = 0\n      , frequency = 1\n      , rotation = 0\n      , preScale = 0\n      , autoScale = true\n      , maxScale = 1;\n\n    function calcScale(x, y, angle) {\n        var width = me.width, height = me.height, scale = 1, x0, y0, x1, y1, x2, y2, sin, cos;\n\n        // angle mod 180\n        angle = angle - PI * Math.floor(angle / PI);\n\n        if (angle) {\n            sin = Math.sin(angle);\n            cos = Math.sqrt(1 - sin * sin);\n\n            /*\n\t\tTake two top corner points, rotate them and find absolute value.\n\t\tThis should find the bounding box of the rotated recangle,\n\t\tassuming it's centered at 0, 0\n\t\t*/\n\n            // rotate point top right corner\n            x0 = width / 2;\n            y0 = height / 2;\n            x1 = Math.abs(x0 * cos - y0 * sin);\n            y1 = Math.abs(x0 * sin + y0 * cos);\n\n            // rotate point top left corner\n            x0 = -x0;\n            x2 = Math.abs(x0 * cos - y0 * sin);\n            y2 = Math.abs(x0 * sin + y0 * cos);\n\n            // find maximum scale\n            scale = 2 * Math.max(x1 / width, x2 / width, y1 / height, y2 / height);\n        }\n\n        scale *= Math.max((2 * Math.abs(x) + width) / width, (2 * Math.abs(y) + height) / height);\n\n        return scale;\n    }\n\n    function recompute() {\n        var matrix = me.matrix, s, c, t, freq, amp, adjust = 0, i, scale = 1, translateX = 0, translateY = 0, rotationZ = 0, angle = 0, m00, m01, m02, m03, m10, m11, m12, m13;\n\n        function translate(x, y) {\n            matrix[12] = matrix[0] * x + matrix[4] * y + matrix[12];\n            matrix[13] = matrix[1] * x + matrix[5] * y + matrix[13];\n            matrix[14] = matrix[2] * x + matrix[6] * y + matrix[14];\n            matrix[15] = matrix[3] * x + matrix[7] * y + matrix[15];\n        }\n\n        function rotateZ() {\n            if (!rotationZ) {\n                return;\n            }\n\n            s = Math.sin(angle);\n            c = Math.cos(angle);\n\n            m00 = matrix[0];\n            m01 = matrix[1];\n            m02 = matrix[2];\n            m03 = matrix[3];\n            m10 = matrix[4];\n            m11 = matrix[5];\n            m12 = matrix[6];\n            m13 = matrix[7];\n\n            matrix[0] = m00 * c + m10 * s;\n            matrix[1] = m01 * c + m11 * s;\n            matrix[2] = m02 * c + m12 * s;\n            matrix[3] = m03 * c + m13 * s;\n            matrix[4] = m10 * c - m00 * s;\n            matrix[5] = m11 * c - m01 * s;\n            matrix[6] = m12 * c - m02 * s;\n            matrix[7] = m13 * c - m03 * s;\n        }\n\n        if (!amplitudeX && !amplitudeY && !rotation) {\n            me.transformed = false;\n            return;\n        }\n\n        t = time * frequency;\n\n        for (i = 0; i < octaves; i++) {\n            freq = Math.pow(2, i);\n            amp = Math.pow(0.5, i);\n            adjust += amp;\n            if (rotation) {\n                rotationZ += noise2D(t * freq, 7 * freq) * amp;\n            }\n            if (amplitudeX) {\n                translateX += noise2D(t * freq, 11 * freq) * amp;\n            }\n            if (amplitudeY) {\n                translateY += noise2D(t * freq, 13 * freq) * amp;\n            }\n        }\n        rotationZ *= rotation / adjust;\n        translateX *= amplitudeX / adjust;\n        translateY *= amplitudeY / adjust;\n        angle = rotationZ * PI / 180;\n\n        //calculate transformation matrix\n        mat4.identity(matrix);\n\n        translate(translateX, translateY);\n\n        rotateZ();\n\n        if (autoScale) {\n            if (preScale === 1) {\n                scale = maxScale;\n            } else {\n                scale = calcScale(translateX, translateY, angle);\n                scale = preScale * maxScale + (1 - preScale) * scale;\n            }\n\n            //scale\n            if (scale !== 1) {\n                matrix[0] *= scale;\n                matrix[1] *= scale;\n                matrix[2] *= scale;\n                matrix[3] *= scale;\n                matrix[4] *= scale;\n                matrix[5] *= scale;\n                matrix[6] *= scale;\n                matrix[7] *= scale;\n            }\n        }\n\n        me.transformed = true;\n    }\n\n    initializeSimplex();\n\n    return {\n        me,\n        getTranslation, \n        getScaling, \n        getRotation,\n        resize: recompute,\n        inputs: {\n            time: {\n                get: function() {\n                    return time;\n                },\n                set: function(t) {\n                    if (t === time) {\n                        return false;\n                    }\n\n                    time = t;\n\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            },\n            frequency: {\n                get: function() {\n                    return frequency;\n                },\n                set: function(f) {\n                    if (f === frequency) {\n                        return false;\n                    }\n\n                    frequency = f;\n\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            },\n            octaves: {\n                get: function() {\n                    return octaves;\n                },\n                set: function(o) {\n                    o = Math.max(1, o);\n                    if (o === octaves) {\n                        return false;\n                    }\n\n                    octaves = o;\n\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            },\n            rotation: {\n                get: function() {\n                    return rotation;\n                },\n                set: function(r) {\n                    if (r === rotation) {\n                        return false;\n                    }\n\n                    rotation = r;\n\n                    maxScale = calcScale(amplitudeX, amplitudeY, rotation * PI / 180);\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            },\n            amplitudeX: {\n                get: function() {\n                    return amplitudeX;\n                },\n                set: function(x) {\n                    x = Math.max(0, x);\n                    if (x === amplitudeX) {\n                        return false;\n                    }\n\n                    amplitudeX = x;\n\n                    maxScale = calcScale(amplitudeX, amplitudeY, rotation * PI / 180);\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            },\n            amplitudeY: {\n                get: function() {\n                    return amplitudeY;\n                },\n                set: function(y) {\n                    y = Math.max(0, y);\n                    if (y === amplitudeY) {\n                        return false;\n                    }\n\n                    amplitudeY = y;\n\n                    maxScale = calcScale(amplitudeX, amplitudeY, rotation * PI / 180);\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            },\n            autoScale: {\n                get: function() {\n                    return autoScale;\n                },\n                set: function(a) {\n                    a = !!a;\n                    if (a === autoScale) {\n                        return false;\n                    }\n\n                    autoScale = a;\n\n                    recompute();\n                    return true;\n                },\n                type: 'boolean'\n            },\n            preScale: {\n                get: function() {\n                    return preScale;\n                },\n                set: function(ps) {\n                    ps = Math.max(0, Math.min(1, ps));\n                    if (ps === preScale) {\n                        return false;\n                    }\n\n                    preScale = ps;\n\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            }\n        }\n    };\n}\n\n\n/*\nlet api = makeAwesomeShakyItem()\napi.inputs.amplitudeX.set(10)\n// 0-8-50\n\napi.inputs.amplitudeY.set(10)\n// 0-8-50\n\napi.inputs.rotation.set(5)\n// 0-2-20\n\napi.inputs.frequency.set(4)\n// 0-4-10 / 0.01 step\n\napi.inputs.octaves.set(1)\n// 1-1-4\n\napi.inputs.autoScale.set(false)\n// true-false\n\napi.inputs.preScale.set(1)\n// 0-0.0001-1\n\napi.inputs.time.set(window.performance.now() / 1000)\n// api.resize()\n// console.log(api.me.matrix)\nlet t = api.getTranslation([0,0,0], api.me.matrix)\nlet s = api.getScaling([1,1,1], api.me.matrix)\nlet r = api.getRotation([0,0,0], api.me.matrix)\n\nthis.object3D.rotation.x = r[0]\nthis.object3D.rotation.y = r[1]\nthis.object3D.rotation.z = r[2]\n\nthis.object3D.scale.x = s[0]\nthis.object3D.scale.y = s[1]\nthis.object3D.scale.z = s[2]\n\nthis.object3D.translate.x = t[0]\nthis.object3D.translate.y = t[1]\nthis.object3D.translate.z = t[2]\n\n*/\n\n\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {},\n    timename: {},\n    timetracks: {}\n  },\n  data () {\n    return {\n      camera: false\n    }\n  },\n  methods: {\n    init () {\n      let fov = 75\n      let rect = this.$parent.$el.getBoundingClientRect()\n      let aspect = rect.width / rect.height\n      let near = 0.1\n      let far = 100000000000000\n\n      this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far)\n      this.object3D = new THREE.Object3D()\n      \n      // this.camera.position.z = 500\n      // this.camera.lookAt(0,0,0)\n      \n      //-- -------\n            \n      let api = makeAwesomeShakyItem()\n      api.inputs.amplitudeX.set(2)\n      // 0-8-50\n      \n      api.inputs.amplitudeY.set(2)\n      // 0-8-50\n      \n      api.inputs.rotation.set(5)\n      // 0-2-20\n      \n      api.inputs.frequency.set(4)\n      // 0-4-10 / 0.01 step\n      \n      api.inputs.octaves.set(1)\n      // 1-1-4\n      \n      api.inputs.autoScale.set(false)\n      // true-false\n      \n      api.inputs.preScale.set(1)\n      // 0-0.0001-1\n      \n      let p = [0,0,0]\n      let s = [0,0,0]\n      let r = [0,0,0]\n      \n      let waitGetByType = (getter = () => {}) => {\n        return new Promise((resolve) => {\n          let tt = setInterval(() => {\n            if (getter()) {\n              clearInterval(tt)\n              resolve(getter())\n            }\n          })\n        })\n      }\n\n      // waitGetByType({\n      //   getter: () => {\n      //     return \n      //   }\n      // }).then(() => {\n      // })\n      \n      let getCurrentScene = () => {\n        return this.timetracks.filter(track => track.progress > 0.0001 && track.progress < 1).reduce((carry, track) => {\n          let node = this.nodes.find(n => n.title === track.title)\n          if (node && node.type === 'scene') {\n            if (this.components[node._id] && this.components[node._id].scene) {\n              carry = this.components[node._id].scene\n            }\n          }\n          return carry\n        }, false)\n      }\n      \n      this.$emit('exec', () => {\n        let track = this.timetracks.find(t => t.title === this.node.title && t.progress > 0.001 && t.progress < 1)\n        \n        api.inputs.time.set(window.performance.now() / 1000)\n        \n        p = api.getTranslation(p, api.me.matrix)\n        s = api.getScaling(s, api.me.matrix)\n        r = api.getRotation(r, api.me.matrix)\n        \n        let scene = getCurrentScene()\n        if (scene && track) {\n          scene.rotation.x = r[0]\n          scene.rotation.y = r[1]\n          scene.rotation.z = r[2]\n          \n          scene.scale.x = s[0]\n          scene.scale.y = s[1]\n          scene.scale.z = s[2]\n          \n          scene.position.x = p[0]\n          scene.position.y = p[1]\n          scene.position.z = p[2]\n          \n          // let x = 100 * Math.sin(3.14159265 * 2 * track.progress)\n          // let y = 100 * Math.cos(3.14159265 * 2 * track.progress)\n          \n          this.camera.position.z = 525\n        }\n      })\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n    \n    // this.$emit('exec', () => {\n    //   let item = this.timetracks.find(t => t.title === this.node.title && t.progress > 0.001 && t.progress < 1)\n    //   if (item) {\n    //     this.camera.position.z = (1.0 - item.progress) * -300 + 500\n    //   }\n    // });\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "camera",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_929729",
      "title": "Composers",
      "to": "root",
      "pos": {
        "x": 80.00008000000003,
        "y": 80.00008000000003
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      object3D: false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  methods: {\n    init () {\n      this.object3D = new THREE.Object3D()\n    }\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      this.components[this.node.to].$emit('addChild', { child })\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "organiser.composer",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "confirmRecylce": false,
      "trashed": true
    },
    {
      "_id": "_257968",
      "title": "Glowing Effect",
      "to": "_822493",
      "pos": {
        "x": 440,
        "y": 850
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      bloomPass: false,\n      composer: false\n    }\n  },\n  mounted () {\n    this.init()\n  },\n  methods: {\n    init () {\n      let waitGetByType = (getter = () => {}) => {\n        return new Promise((resolve) => {\n          let tt = setInterval(() => {\n            if (getter()) {\n              clearInterval(tt)\n              resolve(getter())\n            }\n          })\n        })\n      }\n\n      let getStuff = async () => {\n        let self = this\n        return {\n          root: await waitGetByType(() => {\n            let node = this.nodes.find(no => no.type === 'root')\n            if (node) {\n              return this.components[node._id]\n            }\n          }),\n          getCamera: () => {\n            return waitGetByType(() => {\n              let node = self.nodes.find(no => no.type === 'root')\n              let root = self.components[node._id]\n              if (root) {\n                return root.cameras[root.cameraID]\n              }\n            })\n          },\n          getScene: () => {\n            return waitGetByType(() => {\n              let node = this.nodes.find(no => no.type === 'root')\n              let root = this.components[node._id]\n              if (root) {\n                return root.scenes[root.sceneID]\n              }\n            })\n          }\n        }\n      }\n      /*\n      '/threejs/examples/js/shaders/CopyShader.js',\n  \t\t'/threejs/examples/js/shaders/AfterimageShader.js',\n  \t\t'/threejs/examples/js/postprocessing/EffectComposer.js',\n  \t\t'/threejs/examples/js/postprocessing/RenderPass.js',\n  \t\t'/threejs/examples/js/postprocessing/MaskPass.js',\n  \t\t'/threejs/examples/js/postprocessing/ShaderPass.js',\n  \t\t'/threejs/examples/js/postprocessing/AfterimagePass.js'\n      */\n      let scripts = [\n        '/threejs/examples/js/postprocessing/EffectComposer.js',\n        '/threejs/examples/js/postprocessing/RenderPass.js',\n        '/threejs/examples/js/postprocessing/MaskPass.js',\n        '/threejs/examples/js/postprocessing/ShaderPass.js',\n        '/threejs/examples/js/shaders/CopyShader.js',\n        '/threejs/examples/js/shaders/FXAAShader.js',\n        '/threejs/examples/js/shaders/ConvolutionShader.js',\n        '/threejs/examples/js/shaders/LuminosityHighPassShader.js',\n        '/threejs/examples/js/postprocessing/UnrealBloomPass.js'\n      ]\n\n      loadJS(scripts.map(s => {\n        return { url: `https://igraph.effectnode.com${s}` }\n      }))\n        .then(() => {\n          getStuff()\n            .then((args) => {\n              this.setup(args)\n            })\n            .then(() => {\n              this.$emit('ready', this)\n            })\n        })\n\n\n\n      // Promise.all([\n      //   getRoot(),\n      //   findSceneCompo()\n      // ])\n      //   .then((res) => {\n      //     return {\n      //       root: res[0],\n      //       scene: res[1].compo.scene\n      //     }\n      //   })\n      //   .then(({ root, scene }) => {\n      //     this.$emit('exec', () => {\n      //\n\n      //       this.setup({ root, scene })\n      //       this.$emit('ready', this)\n      //     });\n      //   })\n\n    },\n    async setup ({ root, getScene, getCamera }) {\n      let composer = this.composer = new THREE.EffectComposer(root.renderer)\n\n      // this.$on('addToParent', ({ parent }) => {\n      //   console.log(this.node.title, 'addToParent', parent.node.title)\n      // })\n\n      let dpi = 2\n      let size = root.size\n\n      let renderBG = new THREE.RenderPass(await getScene(), await getCamera())\n      composer.addPass(renderBG)\n\n      let bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(size.width * dpi, size.height * dpi), 1.5, 0.4, 0.85)\n      bloomPass.renderToScreen = true\n\n      this.$emit('exec', async () => {\n        renderBG.scene = await getScene()\n        renderBG.camera = await getCamera()\n      })\n\n      this.bloomPass = bloomPass\n\n      window.addEventListener('resize', () => {\n        composer.setSize(size.width * dpi, size.height * dpi)\n      })\n\n      let glow = {\n        // threshold: 0.0846740050804403,\n        // strength: 0.9551227773073666,\n        // radius: 1.0343776460626588,\n        \n        threshold: 0.0846740050804403,\n        strength: 0.5551227773073666,\n        radius: 1.0343776460626588,\n        exposure: 1\n      }\n      this.bloomPass.threshold = glow.threshold\n      this.bloomPass.strength = glow.strength\n      this.bloomPass.radius = glow.radius\n\n      composer.addPass(bloomPass)\n    }\n  },\n  created () {\n    this.$on('addChild', ({ child }) => {\n      // if (child.node.type === 'drawable') {\n      //   this.object3D.add(child.drawable)\n      // }\n      // if (child.node.type === 'object3D') {\n      //   this.object3D.add(child.object3D)\n      // }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    // this.$on('removeFromParent', ({ parent }) => {\n    //   console.log(this.node.title, 'removeFromParent', parent.node.title)\n    // })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n\n",
      "library": [],
      "type": "composer",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_529636",
      "title": "Object 3D",
      "to": "_257968",
      "trashed": true,
      "pos": {
        "x": 80.00008000000003,
        "y": 190.00008000000003
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      object3D: false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  methods: {\n    init () {\n      this.object3D = new THREE.Object3D()\n    }\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'drawable') {\n        this.object3D.add(child.drawable)\n      }\n      if (child.node.type === 'object3D') {\n        this.object3D.add(child.object3D)\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "object3D",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "hasFound": false,
      "confirmRecylce": false
    },
    {
      "_id": "_822493",
      "title": "Composers",
      "to": "root",
      "pos": {
        "x": 260,
        "y": 905
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      object3D: false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  methods: {\n    init () {\n      this.object3D = new THREE.Object3D()\n    }\n  },\n  created () {\n    // this.$on('addToParent', ({ parent }) => {\n    //   console.log(this.node.title, 'addToParent', parent.node.title)\n    // })\n    this.$on('addChild', ({ child }) => {\n      this.components[this.node.to].$emit('addChild', { child })\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    // this.$on('removeFromParent', ({ parent }) => {\n    //   console.log(this.node.title, 'removeFromParent', parent.node.title)\n    // })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "organiser.composer",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false,
      "preventDelete": true,
      "cannotChangeTitle": true
    },
    {
      "_id": "_898849",
      "title": "After Image Effect",
      "to": "_822493",
      "pos": {
        "x": 440,
        "y": 960
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      bloomPass: false,\n      composer: false\n    }\n  },\n  mounted () {\n    this.init()\n  },\n  methods: {\n    init () {\n      let waitGetByType = (getter = () => {}) => {\n        return new Promise((resolve) => {\n          let tt = setInterval(() => {\n            if (getter()) {\n              clearInterval(tt)\n              resolve(getter())\n            }\n          })\n        })\n      }\n      \n      let getStuff = async () => {\n        let self = this\n        return {\n          root: await waitGetByType(() => {\n            let node = this.nodes.find(no => no.type === 'root')\n            if (node) {\n              return this.components[node._id]\n            }\n          }),\n          getCamera: () => {\n            return waitGetByType(() => {\n              let node = self.nodes.find(no => no.type === 'root')\n              let root = self.components[node._id]\n              if (root) {\n                return root.cameras[root.cameraID]\n              }\n            })\n          },\n          getScene: () => {\n            return waitGetByType(() => {\n              let node = this.nodes.find(no => no.type === 'root')\n              let root = this.components[node._id]\n              if (root) {\n                return root.scenes[root.sceneID]\n              }\n            })\n          } \n        }\n      }\n      /*\n      '/threejs/examples/js/shaders/CopyShader.js',\n  \t\t'/threejs/examples/js/shaders/AfterimageShader.js',\n  \t\t'/threejs/examples/js/postprocessing/EffectComposer.js',\n  \t\t'/threejs/examples/js/postprocessing/RenderPass.js',\n  \t\t'/threejs/examples/js/postprocessing/MaskPass.js',\n  \t\t'/threejs/examples/js/postprocessing/ShaderPass.js',\n  \t\t'/threejs/examples/js/postprocessing/AfterimagePass.js'\n      */\n      let scripts = [\n        '/threejs/examples/js/shaders/CopyShader.js',\n    \t\t'/threejs/examples/js/shaders/AfterimageShader.js',\n    \t\t'/threejs/examples/js/postprocessing/EffectComposer.js',\n    \t\t'/threejs/examples/js/postprocessing/RenderPass.js',\n    \t\t'/threejs/examples/js/postprocessing/MaskPass.js',\n    \t\t'/threejs/examples/js/postprocessing/ShaderPass.js',\n    \t\t'/threejs/examples/js/postprocessing/AfterimagePass.js'\n      ]\n      \n      loadJS(scripts.map(s => {\n        return { url: `https://igraph.effectnode.com${s}` }\n      }))\n        .then(() => {\n          getStuff()\n            .then((args) => {\n              this.setup(args)\n            })\n            .then(() => {\n              this.$emit('ready', this)\n            })\n        })\n      \n      \n      \n      // Promise.all([\n      //   getRoot(),\n      //   findSceneCompo()\n      // ])\n      //   .then((res) => {\n      //     return {\n      //       root: res[0],\n      //       scene: res[1].compo.scene\n      //     }\n      //   })\n      //   .then(({ root, scene }) => {\n      //     this.$emit('exec', () => {\n      //       \n            \n      //       this.setup({ root, scene })\n      //       this.$emit('ready', this)\n      //     });\n      //   })\n      \n    },\n    async setup ({ root, getScene, getCamera }) {\n      let composer = this.composer = new THREE.EffectComposer(root.renderer)\n      \n      // this.$on('addToParent', ({ parent }) => {\n      //   console.log(this.node.title, 'addToParent', parent.node.title)\n      // })\n      \n      let dpi = 2\n      let size = root.size\n      \n      let renderBG = new THREE.RenderPass(await getScene(), await getCamera())\n      composer.addPass(renderBG)\n      \n      let afterimagePass = new THREE.AfterimagePass();\n\t\t\tcomposer.addPass( afterimagePass );\n      \n      afterimagePass.uniforms[ \"damp\" ].value = 0.908\n      \n      this.$emit('exec', async () => {\n        renderBG.scene = await getScene()\n        renderBG.camera = await getCamera()\n      })\n      \n      \n      window.addEventListener('resize', () => {\n        composer.setSize(size.width * dpi, size.height * dpi)\n      })\n      \n    }\n  },\n  created () {\n    this.$on('addChild', ({ child }) => {\n      // if (child.node.type === 'drawable') {\n      //   this.object3D.add(child.drawable)\n      // }\n      // if (child.node.type === 'object3D') {\n      //   this.object3D.add(child.object3D)\n      // }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    // this.$on('removeFromParent', ({ parent }) => {\n    //   console.log(this.node.title, 'removeFromParent', parent.node.title)\n    // })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n\n",
      "library": [],
      "type": "composer",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_361580",
      "title": "Mesh",
      "to": "_317698",
      "trashed": true,
      "pos": {
        "x": 620.0000599999998,
        "y": 630.0000599999998
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      geo: false,\n      mat: false,\n      drawable: false\n    }\n  },\n  methods: {\n    init () {\n      // let geo = new THREE.BoxBufferGeometry(100, 100, 100, 20, 20);\n      // let mat = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.1 });\n      this.drawable = new THREE.Mesh()\n      this.drawable.visible = false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'material') {\n        this.drawable.material = child.material\n        this.material = child.material\n      }\n      if (child.node.type === 'geometry') {\n        this.drawable.geometry = child.geometry\n        this.geometry = child.geometry\n      }\n      if (this.geometry && this.material) {\n        this.drawable.visible = true\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "drawable",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "confirmRecylce": false,
      "hasFound": false
    },
    {
      "_id": "_170099",
      "title": "MatCap Material",
      "to": "_361580",
      "trashed": true,
      "pos": {
        "x": 800.0000599999998,
        "y": 575.0000599999998
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  methods: {\n    init () {\n      let url = ''\n      url = `https://raw.githubusercontent.com/mykimbui/matcap/master/matcap.png`\n      // url = `https://raw.githubusercontent.com/mykimbui/matcap/master/matcap2.png`\n      let matcap = new THREE.TextureLoader().load(url, () => {\n        // matcap.encoding = THREE.sRGBEncoding;\n      })\n      let mat = new THREE.MeshMatcapMaterial({ color: 0xffffff, matcap });\n      this.material = mat\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      // if (child.node.type === 'map') {\n      //   this.material.map = child.map\n      // }\n      // if (child.node.type === 'geometry') {\n      //   this.material.geometry = child.geometry\n      // }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "material",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "confirmRecylce": false,
      "hasFound": false
    },
    {
      "_id": "_709900",
      "title": "Sphere Geometry",
      "to": "_361580",
      "trashed": true,
      "pos": {
        "x": 800.0000599999998,
        "y": 685.0000599999998
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  methods: {\n    init () {\n      this.geometry = new THREE.SphereGeometry(56, 32, 32)\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "geometry",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "confirmRecylce": false,
      "hasFound": false
    },
    {
      "_id": "_880019",
      "title": "Object 3D Shaky",
      "to": "_871971",
      "pos": {
        "x": 620.0000299999999,
        "y": 740.0000299999999
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\n// camera shake is from http://brianchirls.github.io/Seriously.js/transforms/seriously.camerashake.js\n\n    /*\nmat4 matrix functions borrowed from gl-matrix by toji\nhttps://github.com/toji/gl-matrix\nLicense: https://github.com/toji/gl-matrix/blob/master/LICENSE.md\n*/\nvar mat4 = {\n    /*\n * mat4.frustum\n * Generates a frustum matrix with the given bounds\n *\n * Params:\n * left, right - scalar, left and right bounds of the frustum\n * bottom, top - scalar, bottom and top bounds of the frustum\n * near, far - scalar, near and far bounds of the frustum\n * dest - Optional, mat4 frustum matrix will be written into\n *\n * Returns:\n * dest if specified, a new mat4 otherwise\n */\n    frustum: function(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = mat4.create();\n        }\n        var rl = (right - left)\n          , tb = (top - bottom)\n          , fn = (far - near);\n        dest[0] = (near * 2) / rl;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 0;\n        dest[4] = 0;\n        dest[5] = (near * 2) / tb;\n        dest[6] = 0;\n        dest[7] = 0;\n        dest[8] = (right + left) / rl;\n        dest[9] = (top + bottom) / tb;\n        dest[10] = -(far + near) / fn;\n        dest[11] = -1;\n        dest[12] = 0;\n        dest[13] = 0;\n        dest[14] = -(far * near * 2) / fn;\n        dest[15] = 0;\n        return dest;\n    },\n\n    perspective: function(fovy, aspect, near, far, dest) {\n        var top = near * Math.tan(fovy * Math.PI / 360.0)\n          , right = top * aspect;\n        return mat4.frustum(-right, right, -top, top, near, far, dest);\n    },\n    multiply: function(dest, mat, mat2) {\n        // Cache the matrix values (makes for huge speed increases!)\n        var a00 = mat[0]\n          , a01 = mat[1]\n          , a02 = mat[2]\n          , a03 = mat[3]\n          , a10 = mat[4]\n          , a11 = mat[5]\n          , a12 = mat[6]\n          , a13 = mat[7]\n          , a20 = mat[8]\n          , a21 = mat[9]\n          , a22 = mat[10]\n          , a23 = mat[11]\n          , a30 = mat[12]\n          , a31 = mat[13]\n          , a32 = mat[14]\n          , a33 = mat[15]\n          , // Cache only the current line of the second matrix\n        b0 = mat2[0]\n          , b1 = mat2[1]\n          , b2 = mat2[2]\n          , b3 = mat2[3];\n        dest[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        dest[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        dest[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        dest[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = mat2[4];\n        b1 = mat2[5];\n        b2 = mat2[6];\n        b3 = mat2[7];\n        dest[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        dest[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        dest[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        dest[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = mat2[8];\n        b1 = mat2[9];\n        b2 = mat2[10];\n        b3 = mat2[11];\n        dest[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        dest[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        dest[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        dest[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        b0 = mat2[12];\n        b1 = mat2[13];\n        b2 = mat2[14];\n        b3 = mat2[15];\n        dest[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n        dest[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n        dest[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n        dest[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n        return dest;\n    },\n    identity: function(dest) {\n        dest[0] = 1;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 0;\n        dest[4] = 0;\n        dest[5] = 1;\n        dest[6] = 0;\n        dest[7] = 0;\n        dest[8] = 0;\n        dest[9] = 0;\n        dest[10] = 1;\n        dest[11] = 0;\n        dest[12] = 0;\n        dest[13] = 0;\n        dest[14] = 0;\n        dest[15] = 1;\n        return dest;\n    },\n    copy: function(out, a) {\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        out[3] = a[3];\n        out[4] = a[4];\n        out[5] = a[5];\n        out[6] = a[6];\n        out[7] = a[7];\n        out[8] = a[8];\n        out[9] = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n        return out;\n    }\n}\n\n\n/**\n* Returns the translation vector component of a transformation\n*  matrix. If a matrix is built with fromRotationTranslation,\n*  the returned vector will be the same as the translation vector\n*  originally supplied.\n* @param  {vec3} out Vector to receive translation component\n* @param  {mat4} mat Matrix to be decomposed (input)\n* @return {vec3} out\n*/\nfunction getTranslation(out, mat) {\n    out[0] = mat[12];\n    out[1] = mat[13];\n    out[2] = mat[14];\n    return out;\n}\n/**\n* Returns the scaling factor component of a transformation\n*  matrix. If a matrix is built with fromRotationTranslationScale\n*  with a normalized Quaternion paramter, the returned vector will be\n*  the same as the scaling vector\n*  originally supplied.\n* @param  {vec3} out Vector to receive scaling factor component\n* @param  {mat4} mat Matrix to be decomposed (input)\n* @return {vec3} out\n*/\nfunction getScaling(out, mat) {\n    let m11 = mat[0];\n    let m12 = mat[1];\n    let m13 = mat[2];\n    let m21 = mat[4];\n    let m22 = mat[5];\n    let m23 = mat[6];\n    let m31 = mat[8];\n    let m32 = mat[9];\n    let m33 = mat[10];\n    out[0] = Math.hypot(m11, m12, m13);\n    out[1] = Math.hypot(m21, m22, m23);\n    out[2] = Math.hypot(m31, m32, m33);\n    return out;\n}\n/**\n* Returns a quaternion representing the rotational component\n*  of a transformation matrix. If a matrix is built with\n*  fromRotationTranslation, the returned quaternion will be the\n*  same as the quaternion originally supplied.\n* @param {quat} out Quaternion to receive the rotation component\n* @param {mat4} mat Matrix to be decomposed (input)\n* @return {quat} out\n*/\nfunction getRotation(out, mat) {\n    let scaling = [0, 0, 0];\n    getScaling(scaling, mat);\n    let is1 = 1 / scaling[0];\n    let is2 = 1 / scaling[1];\n    let is3 = 1 / scaling[2];\n    let sm11 = mat[0] * is1;\n    let sm12 = mat[1] * is2;\n    let sm13 = mat[2] * is3;\n    let sm21 = mat[4] * is1;\n    let sm22 = mat[5] * is2;\n    let sm23 = mat[6] * is3;\n    let sm31 = mat[8] * is1;\n    let sm32 = mat[9] * is2;\n    let sm33 = mat[10] * is3;\n    let trace = sm11 + sm22 + sm33;\n    let S = 0;\n    if (trace > 0) {\n        S = Math.sqrt(trace + 1.0) * 2;\n        out[3] = 0.25 * S;\n        out[0] = (sm23 - sm32) / S;\n        out[1] = (sm31 - sm13) / S;\n        out[2] = (sm12 - sm21) / S;\n    } else if ((sm11 > sm22) && (sm11 > sm33)) {\n        S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n        out[3] = (sm23 - sm32) / S;\n        out[0] = 0.25 * S;\n        out[1] = (sm12 + sm21) / S;\n        out[2] = (sm31 + sm13) / S;\n    } else if (sm22 > sm33) {\n        S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n        out[3] = (sm31 - sm13) / S;\n        out[0] = (sm12 + sm21) / S;\n        out[1] = 0.25 * S;\n        out[2] = (sm23 + sm32) / S;\n    } else {\n        S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n        out[3] = (sm12 - sm21) / S;\n        out[0] = (sm31 + sm13) / S;\n        out[1] = (sm23 + sm32) / S;\n        out[2] = 0.25 * S;\n    }\n    return out;\n}\n\n\n\n/*\nCamera Shake\n- amplitude (x/y)\n- rotation (degrees)\n- frequency\n- octaves\n- autoScale (true/false)\n*/\n\n/*\nSimplex Noise\nadapted from https://github.com/jwagner/simplex-noise.js\n*/\n\nvar PI = Math.PI, f2 = 0.5 * (Math.sqrt(3.0) - 1.0), g2 = (3.0 - Math.sqrt(3.0)) / 6.0, random = Math.random, p, perm, permMod12, grad3, initialized = false;\n\nfunction initializeSimplex() {\n    //initialize simplex lookup tables\n    var i;\n    if (!initialized) {\n        p = new Uint8Array(256);\n        perm = new Uint8Array(512);\n        permMod12 = new Uint8Array(512);\n        grad3 = new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]);\n\n        for (i = 0; i < 256; i++) {\n            p[i] = random() * 256;\n        }\n        for (i = 0; i < 512; i++) {\n            perm[i] = p[i & 255];\n            permMod12[i] = perm[i] % 12;\n        }\n        initialized = true;\n    }\n}\n\nfunction noise2D(xin, yin) {\n    var n0 = 0, // Noise contributions from the three corners\n    n1 = 0, // Skew the input space to determine which simplex cell we're in\n    n2 = 0, s = (xin + yin) * f2, // Hairy factor for 2D\n    i = Math.floor(xin + s), j = Math.floor(yin + s), t = (i + j) * g2, xx0 = i - t, // Unskew the cell origin back to (x,y) space\n    yy0 = j - t, x0 = xin - xx0, y0 = yin - yy0, /*\n    For the 2D case, the simplex shape is an equilateral triangle.\n    Determine which simplex we are in.\n\n    Offsets for second (middle) corner of simplex in (i,j) coords\n    */\n    i1 = x0 > y0 ? 1 : 0, j1 = (i1 + 1) % 2, //opposite of i1\n\n    x1 = x0 - i1 + g2, y1 = y0 - j1 + g2, x2 = x0 - 1 + 2 * g2, y2 = y0 - 1 + 2 * g2, ii = i & 255, jj = j & 255, t0 = 0.5 - x0 * x0 - y0 * y0, t1, t2, gi;\n\n    if (t0 >= 0) {\n        gi = permMod12[ii + perm[jj]] * 3;\n        t0 *= t0;\n        n0 = t0 * t0 * (grad3[gi] * x0 + grad3[gi + 1] * y0);\n        // (x,y) of grad3 used for 2D gradient\n    }\n\n    t1 = 0.5 - x1 * x1 - y1 * y1;\n    if (t1 >= 0) {\n        gi = permMod12[ii + i1 + perm[jj + j1]] * 3;\n        t1 *= t1;\n        n1 = t1 * t1 * (grad3[gi] * x1 + grad3[gi + 1] * y1);\n    }\n\n    t2 = 0.5 - x2 * x2 - y2 * y2;\n    if (t2 >= 0) {\n        gi = permMod12[ii + 1 + perm[jj + 1]] * 3;\n        t2 *= t2;\n        n2 = t2 * t2 * (grad3[gi] * x2 + grad3[gi + 1] * y2);\n    }\n\n    return 70.0 * (n0 + n1 + n2);\n}\n\nfunction makeAwesomeShakyItem() {\n    var me = {\n        width: 100,\n        height: 100,\n        transformed: false,\n        matrix: mat4.identity([])\n    }\n      , octaves = 1\n      , time = 0\n      , amplitudeX = 0\n      , amplitudeY = 0\n      , frequency = 1\n      , rotation = 0\n      , preScale = 0\n      , autoScale = true\n      , maxScale = 1;\n\n    function calcScale(x, y, angle) {\n        var width = me.width, height = me.height, scale = 1, x0, y0, x1, y1, x2, y2, sin, cos;\n\n        // angle mod 180\n        angle = angle - PI * Math.floor(angle / PI);\n\n        if (angle) {\n            sin = Math.sin(angle);\n            cos = Math.sqrt(1 - sin * sin);\n\n            /*\n\t\tTake two top corner points, rotate them and find absolute value.\n\t\tThis should find the bounding box of the rotated recangle,\n\t\tassuming it's centered at 0, 0\n\t\t*/\n\n            // rotate point top right corner\n            x0 = width / 2;\n            y0 = height / 2;\n            x1 = Math.abs(x0 * cos - y0 * sin);\n            y1 = Math.abs(x0 * sin + y0 * cos);\n\n            // rotate point top left corner\n            x0 = -x0;\n            x2 = Math.abs(x0 * cos - y0 * sin);\n            y2 = Math.abs(x0 * sin + y0 * cos);\n\n            // find maximum scale\n            scale = 2 * Math.max(x1 / width, x2 / width, y1 / height, y2 / height);\n        }\n\n        scale *= Math.max((2 * Math.abs(x) + width) / width, (2 * Math.abs(y) + height) / height);\n\n        return scale;\n    }\n\n    function recompute() {\n        var matrix = me.matrix, s, c, t, freq, amp, adjust = 0, i, scale = 1, translateX = 0, translateY = 0, rotationZ = 0, angle = 0, m00, m01, m02, m03, m10, m11, m12, m13;\n\n        function translate(x, y) {\n            matrix[12] = matrix[0] * x + matrix[4] * y + matrix[12];\n            matrix[13] = matrix[1] * x + matrix[5] * y + matrix[13];\n            matrix[14] = matrix[2] * x + matrix[6] * y + matrix[14];\n            matrix[15] = matrix[3] * x + matrix[7] * y + matrix[15];\n        }\n\n        function rotateZ() {\n            if (!rotationZ) {\n                return;\n            }\n\n            s = Math.sin(angle);\n            c = Math.cos(angle);\n\n            m00 = matrix[0];\n            m01 = matrix[1];\n            m02 = matrix[2];\n            m03 = matrix[3];\n            m10 = matrix[4];\n            m11 = matrix[5];\n            m12 = matrix[6];\n            m13 = matrix[7];\n\n            matrix[0] = m00 * c + m10 * s;\n            matrix[1] = m01 * c + m11 * s;\n            matrix[2] = m02 * c + m12 * s;\n            matrix[3] = m03 * c + m13 * s;\n            matrix[4] = m10 * c - m00 * s;\n            matrix[5] = m11 * c - m01 * s;\n            matrix[6] = m12 * c - m02 * s;\n            matrix[7] = m13 * c - m03 * s;\n        }\n\n        if (!amplitudeX && !amplitudeY && !rotation) {\n            me.transformed = false;\n            return;\n        }\n\n        t = time * frequency;\n\n        for (i = 0; i < octaves; i++) {\n            freq = Math.pow(2, i);\n            amp = Math.pow(0.5, i);\n            adjust += amp;\n            if (rotation) {\n                rotationZ += noise2D(t * freq, 7 * freq) * amp;\n            }\n            if (amplitudeX) {\n                translateX += noise2D(t * freq, 11 * freq) * amp;\n            }\n            if (amplitudeY) {\n                translateY += noise2D(t * freq, 13 * freq) * amp;\n            }\n        }\n        rotationZ *= rotation / adjust;\n        translateX *= amplitudeX / adjust;\n        translateY *= amplitudeY / adjust;\n        angle = rotationZ * PI / 180;\n\n        //calculate transformation matrix\n        mat4.identity(matrix);\n\n        translate(translateX, translateY);\n\n        rotateZ();\n\n        if (autoScale) {\n            if (preScale === 1) {\n                scale = maxScale;\n            } else {\n                scale = calcScale(translateX, translateY, angle);\n                scale = preScale * maxScale + (1 - preScale) * scale;\n            }\n\n            //scale\n            if (scale !== 1) {\n                matrix[0] *= scale;\n                matrix[1] *= scale;\n                matrix[2] *= scale;\n                matrix[3] *= scale;\n                matrix[4] *= scale;\n                matrix[5] *= scale;\n                matrix[6] *= scale;\n                matrix[7] *= scale;\n            }\n        }\n\n        me.transformed = true;\n    }\n\n    initializeSimplex();\n\n    return {\n        me,\n        getTranslation, \n        getScaling, \n        getRotation,\n        resize: recompute,\n        inputs: {\n            time: {\n                get: function() {\n                    return time;\n                },\n                set: function(t) {\n                    if (t === time) {\n                        return false;\n                    }\n\n                    time = t;\n\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            },\n            frequency: {\n                get: function() {\n                    return frequency;\n                },\n                set: function(f) {\n                    if (f === frequency) {\n                        return false;\n                    }\n\n                    frequency = f;\n\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            },\n            octaves: {\n                get: function() {\n                    return octaves;\n                },\n                set: function(o) {\n                    o = Math.max(1, o);\n                    if (o === octaves) {\n                        return false;\n                    }\n\n                    octaves = o;\n\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            },\n            rotation: {\n                get: function() {\n                    return rotation;\n                },\n                set: function(r) {\n                    if (r === rotation) {\n                        return false;\n                    }\n\n                    rotation = r;\n\n                    maxScale = calcScale(amplitudeX, amplitudeY, rotation * PI / 180);\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            },\n            amplitudeX: {\n                get: function() {\n                    return amplitudeX;\n                },\n                set: function(x) {\n                    x = Math.max(0, x);\n                    if (x === amplitudeX) {\n                        return false;\n                    }\n\n                    amplitudeX = x;\n\n                    maxScale = calcScale(amplitudeX, amplitudeY, rotation * PI / 180);\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            },\n            amplitudeY: {\n                get: function() {\n                    return amplitudeY;\n                },\n                set: function(y) {\n                    y = Math.max(0, y);\n                    if (y === amplitudeY) {\n                        return false;\n                    }\n\n                    amplitudeY = y;\n\n                    maxScale = calcScale(amplitudeX, amplitudeY, rotation * PI / 180);\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            },\n            autoScale: {\n                get: function() {\n                    return autoScale;\n                },\n                set: function(a) {\n                    a = !!a;\n                    if (a === autoScale) {\n                        return false;\n                    }\n\n                    autoScale = a;\n\n                    recompute();\n                    return true;\n                },\n                type: 'boolean'\n            },\n            preScale: {\n                get: function() {\n                    return preScale;\n                },\n                set: function(ps) {\n                    ps = Math.max(0, Math.min(1, ps));\n                    if (ps === preScale) {\n                        return false;\n                    }\n\n                    preScale = ps;\n\n                    recompute();\n                    return true;\n                },\n                type: 'number'\n            }\n        }\n    };\n}\n\n\n\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    timetracks: {},\n    components: {}\n  },\n  data () {\n    return {\n      object3D: false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  methods: {\n    init () {\n      this.object3D = new THREE.Object3D()\n            \n      let api = makeAwesomeShakyItem()\n      api.inputs.amplitudeX.set(10)\n      // 0-8-50\n      \n      api.inputs.amplitudeY.set(10)\n      // 0-8-50\n      \n      api.inputs.rotation.set(5)\n      // 0-2-20\n      \n      api.inputs.frequency.set(4)\n      // 0-4-10 / 0.01 step\n      \n      api.inputs.octaves.set(1)\n      // 1-1-4\n      \n      api.inputs.autoScale.set(false)\n      // true-false\n      \n      api.inputs.preScale.set(1)\n      // 0-0.0001-1\n      \n      this.$emit('exec', () => {\n        \n        api.inputs.time.set(window.performance.now() / 1000)\n        // api.resize()\n        // console.log(api.me.matrix)\n        let t = api.getTranslation([0,0,0], api.me.matrix)\n        let s = api.getScaling([1,1,1], api.me.matrix)\n        let r = api.getRotation([0,0,0], api.me.matrix)\n        \n        this.object3D.rotation.x = r[0]\n        this.object3D.rotation.y = r[1]\n        this.object3D.rotation.z = r[2]\n        \n        this.object3D.scale.x = s[0]\n        this.object3D.scale.y = s[1]\n        this.object3D.scale.z = s[2]\n        \n        this.object3D.translate.x = t[0]\n        this.object3D.translate.y = t[1]\n        this.object3D.translate.z = t[2]\n        \n        // console.log('translation', translation)\n        // console.log('scaling', scaling)\n        // console.log('rotation', rotation)\n        \n        // console.log(this.timetracks)\n        // let track = this.timetracks.find(t => t.title === this.node.title) \n        // if (track) {\n        //   this.object3D.rotation.z = track.progress * 3.141592 * 2.0\n        // }\n      })\n    }\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'drawable') {\n        this.object3D.add(child.drawable)\n      }\n      if (child.node.type === 'object3D') {\n        this.object3D.add(child.object3D)\n      }\n      \n      // this.components[this.node.to].$emit('addChild', { child })\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "object3D",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false,
      "trashed": true
    },
    {
      "_id": "_718091",
      "title": "Object 3D Shake 2",
      "to": "_880019",
      "pos": {
        "x": 800.0000299999999,
        "y": 740.0000299999999
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\n\n\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    timetracks: {},\n    components: {}\n  },\n  data () {\n    return {\n      object3D: false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  methods: {\n    init () {\n      this.object3D = new THREE.Object3D()\n            \n      \n      \n      this.$emit('exec', () => {\n        \n        \n        \n        // console.log('translation', translation)\n        // console.log('scaling', scaling)\n        // console.log('rotation', rotation)\n        \n        // console.log(this.timetracks)\n        // let track = this.timetracks.find(t => t.title === this.node.title) \n        // if (track) {\n        //   this.object3D.rotation.z = track.progress * 3.141592 * 2.0\n        // }\n      })\n    }\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'drawable') {\n        this.object3D.add(child.drawable)\n      }\n      if (child.node.type === 'object3D') {\n        this.object3D.add(child.object3D)\n      }\n      \n      // this.components[this.node.to].$emit('addChild', { child })\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "object3D",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false,
      "trashed": true
    },
    {
      "_id": "_283608",
      "title": "Volumetric Scene",
      "to": "_29338",
      "pos": {
        "x": 440,
        "y": 740
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      scene: false\n    }\n  },\n  methods: {\n    init () {\n      this.scene = new THREE.Scene()\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      // if camera then pass to parent\n      if (child.node.type === 'camera') {\n        this.components[this.node.to].$emit('addChild', { child })\n      }\n\n      // add here\n      if (child.node.type === 'object3D') {\n        this.scene.add(child.object3D)\n      }\n      if (child.node.type === 'drawable') {\n        this.scene.add(child.drawable)\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "scene",
      "isActive": false,
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "confirmRecylce": false,
      "hasFound": false
    },
    {
      "_id": "_868481",
      "title": "Mesh",
      "to": "_283608",
      "trashed": true,
      "pos": {
        "x": 620.00001,
        "y": 740.00001
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      geo: false,\n      mat: false,\n      drawable: false\n    }\n  },\n  methods: {\n    init () {\n      // let geo = new THREE.BoxBufferGeometry(100, 100, 100, 20, 20);\n      // let mat = new THREE.MeshBasicMaterial({ color: 0xffff00, opacity: 0.1 });\n      this.drawable = new THREE.Mesh()\n      this.drawable.visible = false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      if (child.node.type === 'material') {\n        this.drawable.material = child.material\n        this.material = child.material\n      }\n      if (child.node.type === 'geometry') {\n        this.drawable.geometry = child.geometry\n        this.geometry = child.geometry\n      }\n      if (this.geometry && this.material) {\n        this.drawable.visible = true\n      }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "drawable",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_891203",
      "title": "MatCap Material",
      "to": "_868481",
      "trashed": true,
      "pos": {
        "x": 800.00001,
        "y": 685.00001
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      material: false\n    }\n  },\n  methods: {\n    init () {\n      let url = ''\n      url = `https://raw.githubusercontent.com/mykimbui/matcap/master/matcap.png`\n      // url = `https://raw.githubusercontent.com/mykimbui/matcap/master/matcap2.png`\n      let matcap = new THREE.TextureLoader().load(url, () => {\n        // matcap.encoding = THREE.sRGBEncoding;\n      })\n      let mat = new THREE.MeshMatcapMaterial({ color: 0xffffff, matcap });\n      this.material = mat\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      // if (child.node.type === 'map') {\n      //   this.material.map = child.map\n      // }\n      // if (child.node.type === 'geometry') {\n      //   this.material.geometry = child.geometry\n      // }\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "material",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_510791",
      "title": "Sphere Geometry",
      "to": "_868481",
      "trashed": true,
      "pos": {
        "x": 800.00001,
        "y": 795.00001
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {}\n  },\n  data () {\n    return {\n      geometry: false\n    }\n  },\n  methods: {\n    init () {\n      this.geometry = new THREE.SphereGeometry(56, 32, 32)\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  created () {\n    this.$on('addToParent', ({ parent }) => {\n      // console.log(this.node.title, 'addToParent', parent.node.title)\n    })\n    this.$on('addChild', ({ child }) => {\n      console.log(this.node.title, 'addChild', child.node.title)\n    })\n    this.$on('removeFromParent', ({ parent }) => {\n      // console.log(this.node.title, 'removeFromParent', parent.node.title)\n    })\n    this.$on('removeChild', ({ child }) => {\n      // console.log(this.node.title, 'removeChild', child.node.title)\n    })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "geometry",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "hasFound": false,
      "isActive": false,
      "confirmRecylce": false
    },
    {
      "_id": "_660923",
      "title": "Volumetric Entity",
      "to": "_283608",
      "pos": {
        "x": 620,
        "y": 740
      },
      "src": "<template>\n  <div>\n\n  </div>\n</template>\n\n<script>\nlet waitGet = (getter = () => {}) => {\n  return new Promise((resolve) => {\n    let tt = setInterval(() => {\n      let result = getter()\n      if (result) {\n        clearInterval(tt)\n        resolve(result)\n      }\n    })\n  })\n};\n\nexport default {\n  props: {\n    node: {},\n    parentNode: {},\n    isRootNode: {},\n\n    nodes: {},\n    components: {},\n    timetracks: {}\n  },\n  data () {\n    return {\n      drawable: false\n    }\n  },\n  mounted () {\n    this.init()\n    this.$emit('ready', this)\n  },\n  methods: {\n    init () {\n      this.drawable = new THREE.Object3D()\n      this.setup()\n    },\n    async setup () {\n      this.pass1 = {\n        vs: `\n\nvarying vec3 worldSpaceCoords;\n\nvoid main()\n{\n  //Set the world space coordinates of the back faces vertices as output.\n  worldSpaceCoords = position + vec3(0.5, 0.5, 0.5); //move it from [-0.5;0.5] to [0,1]\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}`,\n\n        fs: `\nprecision highp float;\nvarying vec3 worldSpaceCoords;\n\nvoid main()\n{\n  //The fragment's world space coordinates as fragment output.\n  gl_FragColor = vec4( worldSpaceCoords.x , worldSpaceCoords.y, worldSpaceCoords.z, 1.0 );\n}\n//Leandro R Barbagallo - 2015 - lebarba at gmail.com\n\n`,\n        uniforms: {\n          time: { value: 0 }\n        }\n      };\n      \n      let renderCompo = await waitGet(() => {\n        let result = false\n        \n        for (var kn in this.components) {\n          let compo = this.components[kn]\n          if (compo.renderer) {\n            result = compo\n          }\n        }\n        return result\n      })\n      console.log(renderCompo)\n      \n      \n      var screenSize = {\n        ...renderCompo.sizeVec2,\n      }\n      this.rtTexture = new THREE.WebGLRenderTarget(256, 256, {\n        minFilter: THREE.LinearFilter,\n        magFilter: THREE.LinearFilter,\n        wrapS: THREE.ClampToEdgeWrapping,\n        wrapT: THREE.ClampToEdgeWrapping,\n        format: THREE.RGBFormat,\n        type: THREE.FloatType,\n        generateMipmaps: false\n      })\n      \n      this.rtTexture2 = new THREE.WebGLRenderTarget(1024, 1024, {\n        minFilter: THREE.LinearFilter,\n        magFilter: THREE.LinearFilter,\n        wrapS: THREE.ClampToEdgeWrapping,\n        wrapT: THREE.ClampToEdgeWrapping,\n        format: THREE.RGBAFormat,\n        generateMipmaps: false\n      })\n\n      this.pass2 = {\n        vs: `\nvarying vec3 worldSpaceCoords;\nvarying vec4 projectedCoords;\n\nvoid main () {\n  worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;\n  gl_Position = projectionMatrix *  modelViewMatrix * vec4( position, 1.0 );\n  projectedCoords =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n      `,\n        fs: `\nprecision highp float;\n\nvarying vec3 worldSpaceCoords;\nvarying vec4 projectedCoords;\nuniform sampler2D tex; //, cubeTex, transferTex;\nuniform float steps;\nuniform float alphaCorrection;\nconst int MAX_STEPS = 128;\n\n// //Acts like a texture3D using Z slices and trilinear filtering.\n// vec4 sampleAs3DTexture2( vec3 texCoord )\n// {\n//   vec4 colorSlice1, colorSlice2;\n//   vec2 texCoordSlice1, texCoordSlice2;\n\n//   //The z coordinate determines which Z slice we have to look for.\n//   //Z slice number goes from 0 to 255.\n//   float zSliceNumber1 = floor(texCoord.z  * 255.0);\n\n//   //As we use trilinear we go the next Z slice.\n//   float zSliceNumber2 = min( zSliceNumber1 + 1.0, 255.0); //Clamp to 255\n\n//   //The Z slices are stored in a matrix of 16x16 of Z slices.\n//   //The original UV coordinates have to be rescaled by the tile numbers in each row and column.\n//   texCoord.xy /= 16.0;\n\n//   texCoordSlice1 = texCoordSlice2 = texCoord.xy;\n\n//   //Add an offset to the original UV coordinates depending on the row and column number.\n//   texCoordSlice1.x += (mod(zSliceNumber1, 16.0 ) / 16.0);\n//   texCoordSlice1.y += floor((255.0 - zSliceNumber1) / 16.0) / 16.0;\n\n//   texCoordSlice2.x += (mod(zSliceNumber2, 16.0 ) / 16.0);\n//   texCoordSlice2.y += floor((255.0 - zSliceNumber2) / 16.0) / 16.0;\n\n//   //Get the opacity value from the 2D texture.\n//   //Bilinear filtering is done at each texture2D by default.\n//   colorSlice1 = texture2D( cubeTex, texCoordSlice1 );\n//   colorSlice2 = texture2D( cubeTex, texCoordSlice2 );\n\n//   //Based on the opacity obtained earlier, get the RGB color in the transfer function texture.\n//   colorSlice1.rgb = texture2D( transferTex, vec2( colorSlice1.a, 1.0) ).rgb;\n//   colorSlice2.rgb = texture2D( transferTex, vec2( colorSlice2.a, 1.0) ).rgb;\n\n//   //How distant is zSlice1 to ZSlice2. Used to interpolate between one Z slice and the other.\n//   float zDifference = mod(texCoord.z * 255.0, 1.0);\n\n//   //Finally interpolate between the two intermediate colors of each Z slice.\n//   return mix(colorSlice1, colorSlice2, zDifference) ;\n// }\n\n\n//  Simplex 3D Noise\n//  by Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 );\n  vec4 p = permute( permute( permute(\n              i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  // Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nuniform float time;\nvec4 sampleAs3DTexture (vec3 pos) {\n  float scale = 1.5;\n  vec4 r4 = vec4(\n    abs(snoise(scale * pos + time * 0.25 + pos.x * 0.25)),\n    abs(snoise(scale * pos + time * 0.25 + pos.y * 0.25)),\n    abs(snoise(scale * pos + time * 0.25 + pos.z * 0.25)),\n    0.75\n  );\n\n  r4.a *= abs(r4.r) + abs(r4.g) + abs(r4.b) / float(MAX_STEPS);\n  r4.a = 1.0 - r4.a;\n  r4.rgb = 1.0 - r4.rgb;\n  return r4;\n}\n\nvoid main( void ) {\n  //Transform the coordinates it from [-1;1] to [0;1]\n  vec2 texc = vec2(((projectedCoords.x / projectedCoords.w) + 1.0 ) / 2.0,\n          ((projectedCoords.y / projectedCoords.w) + 1.0 ) / 2.0 );\n\n  //The back position is the world space position stored in the texture.\n  vec3 backPos = texture2D(tex, texc).xyz;\n\n  //The front position is the world space position of the second render pass.\n  vec3 frontPos = worldSpaceCoords;\n\n  //The direction from the front position to back position.\n  vec3 dir = backPos - frontPos;\n\n  float rayLength = length(dir);\n\n  //Calculate how long to increment in each step.\n  float delta = 1.0 / steps;\n\n  //The increment in each direction for each step.\n  vec3 deltaDirection = normalize(dir) * delta;\n  float deltaDirectionLength = length(deltaDirection);\n\n  //Start the ray casting from the front position.\n  vec3 currentPosition = frontPos;\n\n  //The color accumulator.\n  vec4 accumulatedColor = vec4(0.0);\n\n  //The alpha value accumulated so far.\n  float accumulatedAlpha = 0.0;\n\n  //How long has the ray travelled so far.\n  float accumulatedLength = 0.0;\n\n  vec4 colorSample;\n  float alphaSample;\n\n  //Perform the ray marching iterations\n  for(int i = 0; i < MAX_STEPS; i++)\n  {\n    //Get the voxel intensity value from the 3D texture.\n    colorSample = sampleAs3DTexture( currentPosition );\n\n    //Allow the alpha correction customization\n    alphaSample = colorSample.a * alphaCorrection;\n\n    //Perform the composition.\n    accumulatedColor += (1.0 - accumulatedAlpha) * colorSample * alphaSample;\n\n    //Store the alpha accumulated so far.\n    accumulatedAlpha += alphaSample;\n\n    //Advance the ray.\n    currentPosition += deltaDirection;\n    accumulatedLength += deltaDirectionLength;\n\n    //If the length traversed is more than the ray length, or if the alpha accumulated reaches 1.0 then exit.\n    if (accumulatedLength >= rayLength || accumulatedAlpha >= 1.0)\n    // if (accumulatedAlpha >= 1.0)\n      break;\n  }\n\n  gl_FragColor  = accumulatedColor;\n  //Leandro R Barbagallo - 2015 - lebarba at gmail.com\n}`,\n\n        uniforms: {\n          steps: { value: 10 },\n          alphaCorrection: { value: 0.85 },\n          tex: { value: this.rtTexture.texture },\n          time: { value: 0 }\n        }\n      };\n      \n      let getCurrentCamera = () => {\n        return this.timetracks.filter(track => track.progress > 0.0001 && track.progress < 1).reduce((carry, track) => {\n          let node = this.nodes.find(n => n.title === track.title)\n          if (node && node.type === 'camera') {\n            if (this.components[node._id] && this.components[node._id].camera) {\n              carry = this.components[node._id].camera\n            }\n          }\n          return carry\n        }, false)\n      }\n      let getCurrentScene = () => {\n        return this.timetracks.filter(track => track.progress > 0.0001 && track.progress < 1).reduce((carry, track) => {\n          let node = this.nodes.find(n => n.title === track.title)\n          if (node && node.type === 'camera') {\n            if (this.components[node._id] && this.components[node._id].camera) {\n              carry = this.components[node._id].camera\n            }\n          }\n          return carry\n        }, false)\n      }\n      \n      this.scenePass1 = new THREE.Scene();\n      this.scenePass2 = new THREE.Scene();\n      \n      let mat1 = new THREE.ShaderMaterial({\n        uniforms: this.pass1.uniforms,\n        vertexShader: this.pass1.vs,\n        fragmentShader: this.pass1.fs,\n        transparent: false,\n        side: THREE.BackSide\n      });\n      let box1 = new THREE.SphereBufferGeometry(0.75, 128, 128);\n      let drawable1 = new THREE.Mesh(box1, mat1);\n      \n      \n      this.scenePass1.add(drawable1);\n      \n      let mat2 = new THREE.ShaderMaterial({\n        uniforms: this.pass2.uniforms,\n        vertexShader: this.pass2.vs,\n        fragmentShader: this.pass2.fs,\n        transparent: true,\n        side: THREE.FrontSide\n      });\n      let box2 = new THREE.SphereBufferGeometry(0.75, 128, 128);\n      let drawable2 = new THREE.Mesh(box2, mat2);\n      this.scenePass2.add(drawable2);\n      \n      \n      let mat3 = new THREE.MeshBasicMaterial({ map: this.rtTexture2.texture })\n      let geo3 = new THREE.PlaneBufferGeometry(800, 800, 20, 20);\n      let mesh = new THREE.Mesh(geo3, mat3);\n      this.drawable.add(mesh);\n      \n      let camera = new THREE.PerspectiveCamera( 75, 2.0 / 2.0, 0.0001, 1000000 );\n      \n      this.$emit('exec', () => {\n        let time = window.performance.now() * 0.001\n        this.pass1.uniforms.time.value = time\n        this.pass2.uniforms.time.value = time\n        this.pass2.uniforms.tex.value = this.rtTexture.texture\n        mat3.needsUpdate = true\n      \n        // let camera = getCurrentCamera();\n        let oldPos = camera.position.z;\n        \n        camera.position.z = 1.5;\n        let oldRenderTarget = renderCompo.renderer.getRenderTarget()\n        renderCompo.renderer.setRenderTarget(this.rtTexture)\n        renderCompo.renderer.render(this.scenePass1, camera)\n        renderCompo.renderer.setRenderTarget(this.rtTexture2)\n        renderCompo.renderer.render(this.scenePass2, camera)\n        \n        renderCompo.renderer.setRenderTarget(oldRenderTarget)\n      });\n    }\n  },\n  created () {\n    // this.$on('addToParent', ({ parent }) => {\n    //   console.log(this.node.title, 'addToParent', parent.node.title)\n    // })\n    // this.$on('addChild', ({ child }) => {\n    //   if (child.node.type === 'drawable') {\n    //     this.object3D.add(child.drawable)\n    //   }\n    //   if (child.node.type === 'object3D') {\n    //     this.object3D.add(child.object3D)\n    //   }\n    //   console.log(this.node.title, 'addChild', child.node.title)\n    // })\n    // this.$on('removeFromParent', ({ parent }) => {\n    //   console.log(this.node.title, 'removeFromParent', parent.node.title)\n    // })\n    // this.$on('removeChild', ({ child }) => {\n    //   console.log(this.node.title, 'removeChild', child.node.title)\n    // })\n  },\n  beforeDestory () {\n    this.$emit('remove', this)\n  }\n}\n</script>\n\n<style>\n\n</style>\n",
      "library": [],
      "type": "drawable",
      "size": {
        "width": 60,
        "height": 60
      },
      "isOverlapping": false,
      "isOverlappingWith": false,
      "isActive": false,
      "confirmRecylce": false,
      "hasFound": false
    }
  ],
  "timeline": {
    "totalTime": "30.1",
    "tracks": [
      {
        "_id": "_91814940643",
        "start": 0,
        "end": 7.8255813953487845,
        "title": "Volumetric Scene",
        "trashed": false
      },
      {
        "_id": "_54214377498",
        "start": 12.627906976744185,
        "end": 21.430232558139522,
        "title": "About Us Scene",
        "trashed": false
      },
      {
        "_id": "_63844190752",
        "start": 21.24418604651163,
        "end": 30.011627906976738,
        "title": "Contact Us Scene",
        "trashed": false
      },
      {
        "_id": "_42591864702",
        "start": 21.31395348837205,
        "end": 29.976744186046442,
        "title": "RotateView Camera",
        "trashed": false
      },
      {
        "_id": "_78321284422",
        "start": 5.176414852314792e-15,
        "end": 21.988372093023354,
        "title": "Glowing Effect",
        "trashed": false
      },
      {
        "_id": "_7896612244",
        "start": 21.348837209302292,
        "end": 29.802325581395362,
        "title": "After Image Effect",
        "trashed": false
      },
      {
        "_id": "_19760380045",
        "start": 6.802325581395343,
        "end": 21.56976744186044,
        "title": "EarthShake Camera",
        "trashed": false
      },
      {
        "_id": "_70461836251",
        "start": 6.976744186046515,
        "end": 14.313953488372082,
        "title": "Home Scene",
        "trashed": false
      },
      {
        "_id": "_6270983808",
        "start": 0,
        "end": 7.023255813953485,
        "title": "Still Camera"
      }
    ]
  },
  "timeinfo": {
    "start": 0,
    "totalTime": "30.1",
    "timelinePlaying": true,
    "timelineControl": "timer",
    "timelinePercentageLast": 0,
    "timelinePercentage": 0,
    "loop": true,
    "elapsed": 0
  }
}